<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMC_Blog</title>
  
  
  <link href="http://lmc.pub/atom.xml" rel="self"/>
  
  <link href="http://lmc.pub/"/>
  <updated>2023-04-09T13:44:04.391Z</updated>
  <id>http://lmc.pub/</id>
  
  <author>
    <name>LMC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【计网】HTTP基础</title>
    <link href="http://lmc.pub/posts/277348140.html"/>
    <id>http://lmc.pub/posts/277348140.html</id>
    <published>2023-04-09T13:27:25.000Z</published>
    <updated>2023-04-09T13:44:04.391Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-1-0">HTTP/1.0</h2><p>非持续连接：</p><p>请求一个文件的时候就去建立TCP连接，收到响应马上就关闭。</p><h2 id="HTTP-1-1">HTTP/1.1</h2><p>持续连接：</p><p>请求文件的时候建立TCP连接，然后完成一个文件访问响应之后还是可以继续用的。</p><p>前提是请求的文档全在同一个服务器上。</p><p>流水线方式工作：再还没有respon 的时候就发好几个请求报文，然后批量回复。</p><h2 id="HTTP报文格式">HTTP报文格式</h2><h3 id="请求报文">请求报文</h3><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409213259942.png" alt="image-20230409213259942"></p><p>举例：</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409213423918.png" alt="image-20230409213423918"></p><h3 id="响应报文">响应报文</h3><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409213834822.png" alt="image-20230409213834822"></p><h2 id="HTTP请求方法">HTTP请求方法</h2><p>GET：请求URL标志的文档</p><p>HEAD：请求URL标志的文档的首部</p><p>POST：向服务器发送数据</p><p>PUT：在指明的URL下存储一个文档</p><p>DELETE：删除URL标志的文档</p><p>CONNECT：用于代理服务器</p><p>OPTIONS：请求一些选项信息</p><p>TRACE：用来进行环回测试</p><p>PATCH：对PUT方法的补充，用来对已知资源进行局部更新</p><hr><h2 id="常见状态码">常见状态码</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409213859326.png" alt="image-20230409213859326"></p><h2 id="常见状态行">常见状态行</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409213940025.png" alt="image-20230409213940025"></p><h2 id="Cookie">Cookie</h2><p>在服务器上记录用户信息</p><p>让服务器能够识别用户</p><p>是一种对无状态的HTTP进行状态化的技术</p><p>工作原理</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409214401664.png" alt="image-20230409214401664"></p>]]></content>
    
    
    <summary type="html">【计网】HTTP基础</summary>
    
    
    
    <category term="计算机基础" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计网" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://lmc.pub/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【计网】TCP报文段首部格式</title>
    <link href="http://lmc.pub/posts/1870036843.html"/>
    <id>http://lmc.pub/posts/1870036843.html</id>
    <published>2023-04-09T08:58:35.000Z</published>
    <updated>2023-04-09T13:25:34.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v13">描述</h2><blockquote><p>TCP 报文格式?</p></blockquote><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409171134135.png" alt="image-20230409171134135"></p><p>源端口：发送方进程的端口</p><p>目的端口：接收方进程的端口</p><p>seq序号：数据偏移部分第一个序号</p><p>ack确认号：这个序号之前的字节我都接受了 + 请给我发从这个序号之后的字节</p><p>数据偏移：TCP首部有多长</p><p>保留：没东西</p><p>窗口：发送的一方自己的接受窗口大小</p><p>校验和：</p><p>URG：配合紧急指针用的，让发送的那段数据不用缓存直接给上方进程</p><p>SYN：同步序列号</p><p>ACK：确认报文段</p><p>FIN：结束报文段</p><p>RST：超时重传的那个</p><hr><p>参考</p><blockquote><ul><li>源端口(Source Port)和目的端口(Destination Port)：每个16位，用于标识发送方和接收方的应用程序。</li><li>序列号(Sequence Number)和确认号(Acknowledgment Number)：每个32位，序列号表示本次传输的数据的第一个字节的序号，确认号表示期望下一次接收到的字节的序号。</li><li>数据偏移(Data Offset)：4位，表示TCP头部的长度，单位为32位字。最小值为5，最大值为15。</li><li>保留位(Reserved)：6位，保留未使用，必须为0。</li><li>控制位(Flags)：6位，用于标识TCP报文的类型。U表示紧急，A表示确认，P表示推送，R表示重置，S表示同步，F表示结束。</li><li>窗口(Window)：16位，表示接收方还能接收多少字节的数据。</li><li>校验和(Checksum)：16位，用于检测TCP报文是否有错。</li><li>紧急指针(Urgent Pointer)：16位，用于标识紧急数据的边界。</li><li>选项(Options)：长度可变，用于传递额外的信息，如最大报文长度、时间戳等。</li><li>填充(Padding)：长度可变，用于填充选项字段，使TCP头部的长度为32位的倍数。</li><li>数据(Data)：长度可变，表示应用层传输的数据。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">【计网】TCP报文段首部格式</summary>
    
    
    
    <category term="计算机基础" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计网" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://lmc.pub/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【计网】三报文握手，四报文挥手</title>
    <link href="http://lmc.pub/posts/2090942918.html"/>
    <id>http://lmc.pub/posts/2090942918.html</id>
    <published>2023-04-09T08:27:48.000Z</published>
    <updated>2023-04-09T13:23:01.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三握手">三握手</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409163503218.png" alt="image-20230409163503218"></p><p>SYN：同步位 （这个为1，不能携带数据。但是消耗一个序号）</p><p>ACK：确认位</p><p>seq：序号</p><p>ack：确认号</p><p>为什么非要三握手？两握手行不行？</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409163744632.png" alt="image-20230409163744632"></p><h2 id="四挥手">四挥手</h2><p>过程</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409164518495.png" alt="image-20230409164518495"></p><p>客户端为什么还有时间等待，而不是发送最后一个确认报文段直接关闭？</p><blockquote><p>为什么 TIME WAIT 需要等待 2MSL?</p></blockquote><p>1.<img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409164709039.png" alt="image-20230409164709039"></p><p>2.是本次连接持续时间内产生的所有报文段全部从网络中消失，这样新的、TCP连接就不会有旧的连接报文段。</p><h2 id="保活计时器">保活计时器</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409165011702.png" alt="image-20230409165011702"></p>]]></content>
    
    
    <summary type="html">【计网】三报文握手，四报文挥手</summary>
    
    
    
    <category term="计算机基础" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计网" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://lmc.pub/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【算法】前k个高频元素347</title>
    <link href="http://lmc.pub/posts/108615348.html"/>
    <id>http://lmc.pub/posts/108615348.html</id>
    <published>2023-04-09T05:51:30.000Z</published>
    <updated>2023-04-10T14:24:18.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v8">描述</h2><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">前k个高频元素347</a></p><h2 id="分析-v5">分析</h2><h2 id="实现-v6">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//347. 前 K 个高频元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKFrequentElements347</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : <span class="keyword">new</span> <span class="title class_">Solution</span>().topKFrequent(arr,<span class="number">2</span>)) &#123;</span><br><span class="line">System.out.print(item + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">       <span class="comment">//统计频率</span></span><br><span class="line">Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : nums) &#123;</span><br><span class="line">map.put(item,map.getOrDefault(item,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2) -&gt; pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出k</span></span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k ; i++) &#123;</span><br><span class="line">res[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v7">总结</h2><p>主要是集合那些方法不太熟悉了</p>]]></content>
    
    
    <summary type="html">【算法】前k个高频元素347</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】滑动窗口最大值239</title>
    <link href="http://lmc.pub/posts/1607998336.html"/>
    <id>http://lmc.pub/posts/1607998336.html</id>
    <published>2023-04-09T05:50:42.000Z</published>
    <updated>2023-04-10T13:30:49.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v9">描述</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值239</a></p><h2 id="分析-v6">分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//239. 滑动窗口最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowMaximum239</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : <span class="keyword">new</span> <span class="title class_">Solution</span>().maxSlidingWindow(arr,k)) &#123;</span><br><span class="line">System.out.print(item + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先进k个队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    myQueue.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res[temp++] = myQueue.peek();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> k; j &lt; nums.length; j++) &#123;</span><br><span class="line">    myQueue.poll(nums[j - k]);</span><br><span class="line">    myQueue.add(nums[j]);</span><br><span class="line">    res[temp++] = myQueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//poll</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peek() == num) &#123;</span><br><span class="line">deque.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//add</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; num &gt; deque.getLast()) deque.removeLast();</span><br><span class="line">deque.add(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//peek</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> deque.peek();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现-v7">实现</h2><h2 id="总结-v8">总结</h2><p>主要是一个思想，你领悟到了没有？</p>]]></content>
    
    
    <summary type="html">第一个hard</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】逆波兰表达式求值150</title>
    <link href="http://lmc.pub/posts/2607567793.html"/>
    <id>http://lmc.pub/posts/2607567793.html</id>
    <published>2023-04-09T05:50:10.000Z</published>
    <updated>2023-04-10T06:10:30.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v12">描述</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值 - 力扣（Leetcode）</a></p><h2 id="分析-v9">分析</h2><p>很简单，一句话。</p><p>遇到数字就怼进去。</p><p>遇到运算符就把栈最上面两个做运算然后结果入栈。</p><p>如此往复。</p><h2 id="实现-v10">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//150. 逆波兰表达式求值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvaluateReversePolishNotation150</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">String[] stringArry = &#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;*&quot;</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;res = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Solution</span>().evalRPN(stringArry));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String item: tokens) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">    stack.push(stack.pop() + stack.pop());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">    stack.push(-stack.pop() + stack.pop());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">    stack.push(stack.pop() * stack.pop());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    stack.push(temp2 / temp1);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    stack.push(Integer.valueOf(item));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v11">总结</h2><p>其实中缀表达式是给人看的，计算机更加喜欢后缀表达式。</p>]]></content>
    
    
    <summary type="html">【算法】逆波兰表达式求值150</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】删除字符串中的所有相邻重复项1047</title>
    <link href="http://lmc.pub/posts/2327252199.html"/>
    <id>http://lmc.pub/posts/2327252199.html</id>
    <published>2023-04-09T05:49:42.000Z</published>
    <updated>2023-04-09T09:40:26.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v7">描述</h2><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047. 删除字符串中的所有相邻重复项 - 力扣（Leetcode）</a></p><h2 id="分析-v4">分析</h2><h2 id="实现-v5">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1047. 删除字符串中的所有相邻重复项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveAllAdjacentDuplicatesInString1047</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Solution</span>().removeDuplicates(<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).nextLine()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    ArrayDeque&lt;Character&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> item : s.toCharArray())&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.isEmpty() || item != res.peek()) &#123;</span><br><span class="line">    res.push(item);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!res.isEmpty())&#123;</span><br><span class="line">    r = res.pop() + r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] res = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; s.length())&#123;</span><br><span class="line">    res[slow] = res[fast];</span><br><span class="line">    <span class="keyword">if</span> (slow &gt; <span class="number">0</span> &amp;&amp; res[slow] == res[slow - <span class="number">1</span>]) &#123;</span><br><span class="line">    slow--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    slow++;</span><br><span class="line">    &#125;</span><br><span class="line">    fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res, <span class="number">0</span>, slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v6">总结</h2><p>以后用双指针法，更加高效。</p>]]></content>
    
    
    <summary type="html">不能用ArrayDeque,用双指针更加高效。</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】有效的括号20</title>
    <link href="http://lmc.pub/posts/4071001534.html"/>
    <id>http://lmc.pub/posts/4071001534.html</id>
    <published>2023-04-09T05:48:48.000Z</published>
    <updated>2023-04-09T09:40:26.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v10">描述</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（Leetcode）</a></p><h2 id="分析-v7">分析</h2><p>先分析有哪几种<code>非有效的括号</code></p><ol><li>左边多了<img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/2020080915505387.png" alt="括号匹配1"></li><li>左右不匹配的<img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/20200809155107397.png" alt="括号匹配2"></li><li>右边多了<img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/20200809155115779.png" alt="括号匹配3"></li></ol><h2 id="实现-v8">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有效的括号20</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidParentheses20</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Solution</span>().isValid(input.nextLine())) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//字符串为奇数，坑定不会yes</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> item : s.toCharArray())&#123;</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">    stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item ==<span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">    stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">    stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != item)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v9">总结</h2>]]></content>
    
    
    <summary type="html">对称匹配类题目很适合用栈</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Bug】java使用了未经检查或者不安全的操作</title>
    <link href="http://lmc.pub/posts/3287331760.html"/>
    <id>http://lmc.pub/posts/3287331760.html</id>
    <published>2023-04-03T23:42:42.000Z</published>
    <updated>2023-04-09T09:40:26.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v3">描述</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230404074311479.png" alt="image-20230404074311479"></p><p>早上起来刷算法的时候，在DOS下面编译java文件的时候突然问发生的。</p><h2 id="分析-v3">分析</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230404074408894.png" alt="image-20230404074408894"></p><p>当时在定义的时候，后面没有图上这两个泛型。</p><h2 id="解决-v3">解决</h2><ol><li>加上泛型</li><li>在main方法面前加@SuppressWarnings(“unchecked”)</li></ol><h2 id="总结-v3">总结</h2><p>JavaSE基础语法要一直熟悉记得，不然就容易犯一些小错误。</p>]]></content>
    
    
    <summary type="html">犯了两次了</summary>
    
    
    
    <category term="Bug" scheme="http://lmc.pub/categories/Bug/"/>
    
    
    <category term="Bug" scheme="http://lmc.pub/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>【算法】用栈实现队列232</title>
    <link href="http://lmc.pub/posts/2605004311.html"/>
    <id>http://lmc.pub/posts/2605004311.html</id>
    <published>2023-04-03T23:04:24.000Z</published>
    <updated>2023-04-09T09:40:26.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v11">描述</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">用栈实现队列232</a></p><h2 id="分析-v8">分析</h2><h2 id="实现-v9">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用栈实现队列232</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImplementQueueUsingStacks232</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">MyQueue</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">System.out.print(<span class="string">&quot;请输入入队数字：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> input.nextInt(); </span><br><span class="line">obj.push(x);</span><br><span class="line">obj.push(<span class="number">66</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">param_2</span> <span class="operator">=</span> obj.pop();</span><br><span class="line">System.out.println(<span class="string">&quot;\npop为： &quot;</span> + param_2);</span><br><span class="line"><span class="type">int</span> <span class="variable">param_3</span> <span class="operator">=</span> obj.peek();</span><br><span class="line">System.out.println(<span class="string">&quot;peek为： &quot;</span> + param_3);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">param_4</span> <span class="operator">=</span> obj.empty();</span><br><span class="line">System.out.println(<span class="string">&quot;链表是否为空：&quot;</span> + param_4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">Stack&lt;Integer&gt; stackIn;</span><br><span class="line">Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    in2Out();</span><br><span class="line">    <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    in2Out();</span><br><span class="line">    <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in2Out</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!stackOut.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stackIn.isEmpty())&#123;</span><br><span class="line">    stackOut.push(stackIn.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v10">总结</h2>]]></content>
    
    
    <summary type="html">主要是两个栈来配合这个队列</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【计网】TCP是怎么实现可靠传输的？</title>
    <link href="http://lmc.pub/posts/874385989.html"/>
    <id>http://lmc.pub/posts/874385989.html</id>
    <published>2023-04-03T12:39:29.000Z</published>
    <updated>2023-04-09T09:40:26.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="官方答案">官方答案</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403204257995.png" alt="image-20230403204257995"></p><h2 id="知识储备">知识储备</h2><h3 id="TCP流量控制">TCP流量控制</h3><blockquote><p>为什么要有 TCP 流量控制？</p></blockquote><p>因为在通信的时候，接收方的接受能力有限。如果发送方一直发，接收方吃不下，接受处理来不及就会造成数据丢失。</p><p>所以就想出来这么一个法子：当一个主机通过 TCP 协议向另一个主机发送数据时候，接受方就会开启一个<code>接受滑动窗口</code>。并由此对发送方的发送策略做出一定的信号进行干涉。</p><blockquote><p>核心的一些技术是什么？</p></blockquote><p><code>滑动窗口，超时重传，零窗口探测报文</code>。</p><blockquote><p>具体过程</p></blockquote><p>首先发送方通过三报文握手和接收方建立连接。</p><p>然后这时候，接收方就产生一个自己的接受窗口。并把这个窗口的大小传回给发送方。</p><p>然后发送方就会把这个值设置为自己的发送窗口。</p><p>然后就把应用程序给的数据分成不同的小组，先发一个小组给接收方，同时每发送一个报文小组就会开启超时重传。</p><p>也就是如果没有在规定时间内接受到这个已发送的报文 respon 就会重新发送这个报文小组。</p><p>这个发送动作会一直存在，直到发送窗口里的报文小组全发出去了。</p><p>接收方接受了这些报文后，会根据自己的缓存实际情况去调整自己的接受窗口大小。</p><p>并会就就接受到的最后一个小组发送一个收到确认报文端。里面会带着新的窗口大小。</p><p>接受方接收到这个respon之后会把发送窗口向后移动，把已经接受的小组移到外面去并删除这些小组。</p><p>然后就调整自己的发送窗口和接受窗口一样大。</p><p>然后就会重复上面这个过程。这之中如果一个发送小组的respon一直不来，等到这个小组的超时重传到时间了，就会重新发送这个小组。</p><p>如果接受窗口调整成0了，那在发送窗口设置成0了之后。发送方会每隔一段时间（零窗口探测报文的超时重传,==也就是持续计时器==）就发送一个只有一个报文的零窗口探测报文，接收方接收到了就立刻发送此时此刻自己的接受窗口给对面。</p><blockquote><p>rwnd：这个接收方返回自己接受窗口的携带变量</p></blockquote><h3 id="TCP的拥塞控制">TCP的拥塞控制</h3><blockquote><p>什么是拥塞？为什么要进行拥塞控制？</p></blockquote><p>拥塞就是一个网络资源的提供是有限的，但是一段时间内却有很多人去请求。导致该网络资源无法再提供给申请者。</p><p>因为实际网络情况中，一个网络通道中随着加入的报文分组越来越多（也就是随着网络负载越来越大），实际返回回来出网络通道的数据（吞吐量）是呈急剧式下跌的，最后会直接不再返回数据。也就直接死锁了。</p><p>对应到现实生活就是APP上有一个资源，比如是一张图片。本来正常的不拥塞的网络，大家一访问就会立马看到显示到手机屏幕上。但是随着想看这个图片的人越来越多，发送到后端服务器的请求越来越多，也就是网络负载增大。服务器返回图片就会越来越慢，从用户点击要看图片到最后加载出来的加载时间越来越长。有些用户就会申请不到图片（丢包率上升。）最终只要网络请求足够多，网络负载达到一定层度，服务器和app之间的通道会直接完全阻塞。不会返回任何数据。</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403211357823.png" alt="image-20230403211357823"></p><p>输入负载：单位时间内给网络通道的分组数量</p><p>吞吐量：单位时间内网络通道出来的分组数量</p><blockquote><p>讨论前提：</p><ol><li>接收方缓存够大，发送窗口只受网络拥塞影响；</li><li>发送的单位直接用完整报文单元；</li><li></li></ol></blockquote><blockquote><p>机制流程</p></blockquote><p>发送方有一个拥塞窗口，然后直接把拥塞窗口作为发送窗口。</p><p>然后拥塞窗口的值是根据网络通道拥塞程度动态变化的。</p><p>而网络拥塞程度是根据发送方是否发生超时重传来额定的。</p><p>有几个值要特别注意：</p><ol><li>慢开始门限值ssthresh</li><li>拥塞窗口cwnd</li><li>发送窗口</li></ol><blockquote><p>解决策略：四种拥塞控制算法</p></blockquote><p><strong>慢开始 + 拥塞控制</strong></p><p>下面的发送窗口 = 拥塞窗口 = 吞吐量</p><p>满开始就是刚开始的发送窗口是 1，然后每接受一个respon就 *2.成指数上升。</p><p>这里的慢指的是，发送窗口开始小，而不是发送大小增长慢。</p><p>然后当发送窗口达到慢开始门限值的时候就会启动拥塞控制，也就是发送窗口现在接受respon 每次就+1，线性增长。</p><p>如果中间发送的分组丢失，导致发送方发生超时重传就断定网络发生了拥塞。慢开始门限值直接变为当前发送窗口一半，然后发送窗口变为1。又开始慢开始算法。</p><p><strong>快重传 + 快恢复</strong></p><p>这个就是在上面的基础上，针对遇到数组丢失的情况做了一点优化。</p><p>之前是发送窗口中的东西发完了，轮到接收方respon的时候接收方顺带返回的。</p><p>现在是直接接收方接收到一个就回复确认一个，如果收到了不按照顺序到达的就直接重发上一个按序的最后一个respon。但是明确是重复标签。</p><p>然后如果发送方连续接受到了三个重复respon （）不包含正常的那个，就重发缺的哪一个</p><p>这时候就是明显拥塞了，上面这个就是快重传。</p><p>然后慢开始门限值和发送窗口统统变成当前吞吐量的一半然后直接线性拥塞控制算法上。</p><h3 id="TCP超时重传时间选择">TCP超时重传时间选择</h3><p>RTO = RTTs + 4*RTTd</p><blockquote><p>RTO：超时重传时间</p><p>RTTs：加权平均往返时间</p></blockquote><p>一般如果发生超时重传，RTO直接变大，准确点是变大 2 倍。</p><h3 id="TCP可靠传输的实现">TCP可靠传输的实现</h3><p>基于<code>以字节为单位的滑动窗口</code>来实现</p><p>rwnd ：接受窗口的大小</p><p>ack：希望收到下一个数据的序号是多少</p><p>如何描绘发送窗口的状态？</p><p>三个指针！</p><p>虽然发送窗口时接受窗口给的，但是同一时刻他两可能不一样。</p><p>因为一个有时延，二个有拥塞机制。</p><p>还有未按需到达的怎么处理，一般是先存起来，然后齐了再统一交付上层。</p>]]></content>
    
    
    <summary type="html">这个最喜欢连着上面那个【TCP与UDP的区别】连着问。</summary>
    
    
    
    <category term="计算机基础" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计网" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://lmc.pub/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【计网】TCP和UDP的区别</title>
    <link href="http://lmc.pub/posts/3604270983.html"/>
    <id>http://lmc.pub/posts/3604270983.html</id>
    <published>2023-04-03T11:53:51.000Z</published>
    <updated>2023-04-09T09:40:26.392Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>首先，TCP（传输控制协议）和UDP（用户数据协议）都是计算机网络体系结构中<strong>运输层</strong>的两个重要协议协议。</p></blockquote><p>他们的区别可以从：</p><ol><li>面向连接</li><li>可靠服务</li><li>基于基础</li><li>适用情况</li></ol><p>这几个方面来进行分析。</p><h2 id="面向连接">面向连接</h2><p>首先，TCP是<strong>面向连接</strong>的，是建立连接之后才传输数据的。他会先进行三报文握手确认网络情况没问题才开始传输数据，然后在断开连接的时候还会进行四报文挥手来断开连接。但是UDP就是直接开始传输数据。</p><h2 id="可靠服务">可靠服务</h2><p>然后，TCP提供的是有链接<strong>可靠</strong>的传输服务，==TCP通过检验和，序列号，确认应答，重发控制，连接管理以及窗口控制等机制来保证自己数据传输的正确性和顺序==。但是UDP提供的无连接不可靠的服务，==它在传输过程中可能丢包。==</p><h2 id="基础">基础</h2><p>还有，TCP是面向字节流的，然后UDP是面向报文对象的。UDP是==应用程序==给我多少报文直接攒好了，一个打包就发过去了。TCP是把<s>字节流</s>==应用程序的数据块==分成很多的小组然后再缓存转发过去。这也是TCP可靠传输的依据。</p><p>TCP通过拥塞控制，流量控制等手段去避免网络拥塞。</p><p>最后一个就是TCP他的报文头是比较消息的，大概20到60字节的具体信息。但是UDP就比较简洁，只有8个字节的具体信息。</p><h2 id="总结-v12">总结</h2><p>总的来说，TCP适合有序，可靠的网络传输。比如文件传输。UDP适合大量及时性传输。比如打电话和视频。</p><h2 id="参考答案">参考答案</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403204337872.png" alt="image-20230403204337872"></p>]]></content>
    
    
    <summary type="html">计网体系运输层最重要的两个协议：TCP UDP</summary>
    
    
    
    <category term="计算机基础" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计网" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://lmc.pub/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【Bug】Hexo博客本地有网站上没有</title>
    <link href="http://lmc.pub/posts/3919582882.html"/>
    <id>http://lmc.pub/posts/3919582882.html</id>
    <published>2023-04-03T08:43:28.000Z</published>
    <updated>2023-04-03T09:33:24.761Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v2">描述</h2><p>昨天遇到一个大Bug，然后准备在手机上看一下已经同步的网站。</p><p>发现没有那文章。</p><p>回来发现：这个文章在本地，但是网上没有。无论是 <code>hexo d</code>的个人网站还是<code>hexo s</code>的本地host预览。</p><h2 id="分析-v2">分析</h2><p>分析了很多，最后我觉得是每篇post头那段文字的问题。</p><ol><li>左边要顶格。<img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403164716334.png" alt="image-20230403164716334"></li><li>分类如果是多层分类那个<code>-</code>要对齐。</li><li>标题以及那个块，==<code>:</code>后面都不要有空格！==</li></ol><p>比如这次，我仔细看 <code>git bash</code> ，我在<code>hexo clean </code>然后<code>hexo g</code>。准备生成文件的时候它提示我：==【Bug】AS什么网络代理无法Builder打包==</p><p>这个genera 生成，然后说错误在line4 那个 <code>:</code>后面。</p><p>我就知道这个地方的<code>:</code>后面有个空格，hexo对于<code>:</code>是非常敏感的。</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403173034272.png" alt="image-20230403173034272"></p><p>然后我们来到这个文件一看，果真<code>:</code>后面有个小空格，容易让 hexo 解析器产生错误。</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403173323253.png" alt="image-20230403173323253"></p><h2 id="总结-v2">总结</h2><p>有时候报错了，多看报错来源和信息。</p><p>比如这次好久没找到的那个posts最上面哪个，在<code>git bash</code>中一直有提示的。在我们 <code>git s</code>的时候。</p>]]></content>
    
    
    <summary type="html">【Bug】Hexo博客本地有网站上没有</summary>
    
    
    
    <category term="Bug" scheme="http://lmc.pub/categories/Bug/"/>
    
    
    <category term="Bug" scheme="http://lmc.pub/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>【其他_Postman】Postman入门使用</title>
    <link href="http://lmc.pub/posts/1670464388.html"/>
    <id>http://lmc.pub/posts/1670464388.html</id>
    <published>2023-04-03T05:41:57.000Z</published>
    <updated>2023-04-03T08:09:20.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v5">描述</h2><p>这是一个API管理工具</p><p>下载地址：<a href="https://www.postman.com/downloads/?utm_source=postman-home">Download Postman | Get Started for Free</a></p><h2 id="导入API">导入API</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403154723184.png" alt="image-20230403154723184"></p><p>主页然后点：workspaces</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403154902561.png" alt="image-20230403154902561"></p><p>然后选择API文件，一般是Json文件</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403154943197.png" alt="image-20230403154943197"></p><p>上面图错了，应该是collections在collections，环境在环境。</p><p>然后collections下面就有了API</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403155510723.png" alt="image-20230403155510723"></p><p>如法炮制，把环境json文件import到环境哪里。并选上你要的那个。</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403155607254.png" alt="image-20230403155607254"></p><p>现在就可以用Postman来看API的请求了。</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403155853202.png" alt="image-20230403155853202"></p><p>右边这里还可以直接生成一些网络代码</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403160330734.png" alt="image-20230403160330734"></p><h2 id="导出">导出</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403160546298.png" alt="image-20230403160546298"></p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403160608225.png" alt="image-20230403160608225"></p><p>然后选择位置就可以了。</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403160633746.png" alt="image-20230403160633746"></p><h2 id="总结-v5">总结</h2><p>后面坑定随着学习的深入会用的越来越多的，先插个眼。</p>]]></content>
    
    
    <summary type="html">API接口管理工具：Postman入门使用</summary>
    
    
    
    <category term="其他" scheme="http://lmc.pub/categories/%E5%85%B6%E4%BB%96/"/>
    
    <category term="Postman" scheme="http://lmc.pub/categories/%E5%85%B6%E4%BB%96/Postman/"/>
    
    
    <category term="Postman" scheme="http://lmc.pub/tags/Postman/"/>
    
  </entry>
  
  <entry>
    <title>【其他_DOS】DOS常用命令</title>
    <link href="http://lmc.pub/posts/2191178889.html"/>
    <id>http://lmc.pub/posts/2191178889.html</id>
    <published>2023-04-03T04:17:47.000Z</published>
    <updated>2023-04-03T08:09:20.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v4">描述</h2><p>DOS虽然远远不如Linux的命令用的多，但是咱穷啊。还没换上mac，难免要在win上面搞几下命令行。</p><p>了解点基础吧。</p><h2 id="DOS常用指令">DOS常用指令</h2><ol><li><p>查看当前目录：dir</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403122057999.png" alt="image-20230403122057999"></p></li><li><p>切换到根目录：cd \</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403122607387.png" alt="image-20230403122607387"></p></li><li><p>返回上一级：cd …</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403122404191.png" alt="image-20230403122404191"></p></li><li><p>清屏：cls</p></li><li><p>退出：exit</p></li><li><p>查看当前目录下层级结构：tree</p></li></ol><h2 id="实现-v3">实现</h2><h2 id="总结-v4">总结</h2>]]></content>
    
    
    <summary type="html">【其他_DOS】DOS常用命令</summary>
    
    
    
    <category term="其他" scheme="http://lmc.pub/categories/%E5%85%B6%E4%BB%96/"/>
    
    <category term="DOS" scheme="http://lmc.pub/categories/%E5%85%B6%E4%BB%96/DOS/"/>
    
    
    <category term="DOS" scheme="http://lmc.pub/tags/DOS/"/>
    
  </entry>
  
  <entry>
    <title>【JavaSE】javareview01</title>
    <link href="http://lmc.pub/posts/1161296855.html"/>
    <id>http://lmc.pub/posts/1161296855.html</id>
    <published>2023-04-03T03:59:59.000Z</published>
    <updated>2023-04-03T08:38:01.923Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JDK">JDK</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403120557975.png" alt="image-20230403120557975"></p><p><strong>Java代码编译过程</strong>：</p><p>一般我们写的都是<code>xx.java</code>文件，然后<code>javac</code>编译成<code>xx.class</code>字节码文件，然后再放到不同的<code>JVM</code>上然后运行出结果。</p><p>如果我们只是运行别人写好的java代码，那只有一个JRE就可以了。</p><h2 id="代码规范">代码规范</h2><ol><li><p>运算符和<code>=</code>前后各一个空格。</p></li><li><p>源代码编码用<code>UTF-8</code>。</p></li><li><p>一行不要太长，最好80字符以内。</p></li><li><p>行尾代码风格；</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403122903088.png" alt="image-20230403122903088"></p></li></ol><h2 id="Java数据类型">Java数据类型</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403123837935.png" alt="image-20230403123837935"></p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403124643861.png" alt="image-20230403124643861"></p><p>几个需要注意的点：</p><ol><li>小数都是大概值，不能比较是否 ==。如果要看两个小数是不是一样大只能说给一个很小的区间然后去判断。</li><li>char的本质就是int，是unicode 码。</li><li>常见的基本数据类型要知道，然后那个数据类型占几个字节要记得。</li></ol><h2 id="Java类型转换">Java类型转换</h2><p>Java的类型转换有两种：自动类型转换和强制类型转换。</p><h3 id="自动类型转换">自动类型转换</h3><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403125708442.png" alt="image-20230403125708442"></p><p>一般来说在不同类型进行计算的时候，往往会将所有的类型自动转成最大的公共类型。</p><h3 id="强制类型转换">强制类型转换</h3><p>一般都是大向小的强转，但是要注意</p><blockquote><p>B otherVariable;</p><p>A variable = (A) otherVariable;</p></blockquote><p>A 必须是 B 的子类。不然就会提示类型转换错误。</p><h2 id="容易疏忽的点">容易疏忽的点</h2><ol><li><p>每个Java源文件只能有一个<code>public</code>类，且这个类名要和源文件名保持一致。</p></li><li><p>提示==缺少<code>;</code>的时候==也有可能是少了一个大括号{}</p></li><li><p>byte 和 short 以及char 在进行运算的都是往往会全部先转成 int</p></li><li><p>char 可以保存整数值，但不能保存整数变量，除非强转。</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403125413934.png" alt="image-20230403125413934"></p></li></ol>]]></content>
    
    
    <summary type="html">JDK &amp; Java代码规范 &amp; Java数据类型以及转换</summary>
    
    
    
    <category term="Java" scheme="http://lmc.pub/categories/Java/"/>
    
    <category term="JavaSE" scheme="http://lmc.pub/categories/Java/JavaSE/"/>
    
    
    <category term="JavaSE" scheme="http://lmc.pub/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>【Bug】AS因为网络代理导致的无法Builder打包</title>
    <link href="http://lmc.pub/posts/3327440864.html"/>
    <id>http://lmc.pub/posts/3327440864.html</id>
    <published>2023-04-03T02:05:48.000Z</published>
    <updated>2023-04-03T09:36:54.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述">描述</h2><p>这个是昨天做项目，准备跑到手机上结果builder打包的时候发生的。</p><p>报错图片如下：</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/1b51343d96f94e9dd5b6ee9eca16e9e.png" alt="1b51343d96f94e9dd5b6ee9eca16e9e"></p><p>具体报错信息如下：</p><blockquote><p>Caused by: org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration$ArtifactResolveException: Could not resolve all files for configuration ‘:app:devDebugCompileClasspath’.</p></blockquote><h2 id="分析">分析</h2><p>当时我通过一下几个步骤寻找solution。</p><ol><li>newBing</li><li>国内浏览器（CSDN）</li><li>StackOverflow</li><li>大佬</li></ol><p>尝试了很多路子但还是失败。</p><hr><p>最后结合各方信息推断：==问题应该还是网络==。</p><p>因为据遇到这个问题的回答，基本都是因为gradle builder 的时候要引入很多国外的开源库。</p><p>但是拉不过来。</p><p>最后发现问题是我的AS代理设置的有问题。</p><p>在设置代理的时候。有 HTTP、HTTPS，Socked</p><p>我设置了前面两个，然后端口用错了。</p><p>这样我的AS就一直连不上网。</p><h2 id="解决">解决</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403101337591.png" alt="image-20230403101337591"></p><p>到这个地址下找到这个文件，然后把代理端口改回来。</p><p>后面就好了。</p><p>对了AS代理最好用HTTP的，因为socked这种可能Bug 不少。</p><hr><p>我发现只有AS的界面改了很多，之前遇到有的帖子也说过改代理。</p><p>但是是在AS中setting里面改的，发现没用。</p><p>然后那个build.gradle文件也不一样。</p><p>最后还是自己去电脑下的user下找的那个文件改了才有用。</p><p>难怪当时设置代理的时候发现不行。</p><h2 id="总结">总结</h2><p>在中国做开发，网络问题一直是程序员的一个大杀器。</p><p>gradle 对网络依赖很重，要妥善处理好AS的代理和编程的网络情况。</p><p><strong>在AS代理设置成正确的HTTP以及端口之后。无论是build还是push github都好用了很多。</strong></p>]]></content>
    
    
    <summary type="html">Caused by:org.gradle.api.internal.artifacts.ivyservice.DefaultLenientConfiguration$ArtifactResolveException:Could not resolve all files for configuration&#39;:app:devDebugCompileClasspath&#39;.</summary>
    
    
    
    <category term="Bug" scheme="http://lmc.pub/categories/Bug/"/>
    
    
    <category term="Bug" scheme="http://lmc.pub/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>【算法】有效的字母异位词242</title>
    <link href="http://lmc.pub/posts/1617761035.html"/>
    <id>http://lmc.pub/posts/1617761035.html</id>
    <published>2023-04-02T09:30:20.000Z</published>
    <updated>2023-04-03T08:59:31.721Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode.cn/problems/valid-anagram/description/">242. 有效的字母异位词 - 力扣（Leetcode）</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有效的字母异位词242</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidAnagram242</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;aee&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;ee&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Solution</span>().isAnagram(s1,s2)) &#123;</span><br><span class="line">System.out.println(s1 + <span class="string">&quot; 和 &quot;</span> + s2 + <span class="string">&quot;是&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(s1 + <span class="string">&quot; 和 &quot;</span> + s2 + <span class="string">&quot;不是&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isAnagram</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] record = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    record[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t.length(); i++) &#123;</span><br><span class="line">    record[t.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : record) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">有效的字母异位词242</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】重复的子字符串459</title>
    <link href="http://lmc.pub/posts/1617761035.html"/>
    <id>http://lmc.pub/posts/1617761035.html</id>
    <published>2023-04-02T09:30:20.000Z</published>
    <updated>2023-04-02T23:38:17.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述-v10">题目描述</h2><p><a href="https://leetcode.cn/problems/repeated-substring-pattern/">重复的子字符串459</a></p><h2 id="代码实现-v7">代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重复的子字符串459</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RepeatedSubstringPattern459</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">System.out.print(<span class="string">&quot;请输入要判断寻找是不是重复子字符串的String = &quot;</span>);</span><br><span class="line">System.out.print(<span class="string">&quot;\n&quot;</span> + <span class="keyword">new</span> <span class="title class_">Solution</span>().repeatedSubstringPattern(input.nextLine()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">repeatedSubstringPattern</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.equals(<span class="string">&quot;&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    getNext(s, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next[len - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; len % (len - next[len - <span class="number">1</span>]) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(String s, <span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s.charAt(j) != s.charAt(i)) j = next[j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(j) == s.charAt(i)) j++;</span><br><span class="line">    <span class="keyword">if</span> (j == s.length()) <span class="keyword">break</span>;</span><br><span class="line">    next[i] = j; </span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人总结-v11">个人总结</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/20220728212157.png" alt="图四"></p><p>正是因为 最长相等前后缀的规则，当一个字符串由重复子串组成的，最长相等前后缀不包含的子串就是最小重复子串。</p><p>上图是证明</p>]]></content>
    
    
    <summary type="html">KMP的另一种考查形式。</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】实现strStr函数28</title>
    <link href="http://lmc.pub/posts/476003832.html"/>
    <id>http://lmc.pub/posts/476003832.html</id>
    <published>2023-04-01T08:09:25.000Z</published>
    <updated>2023-04-02T23:01:48.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述-v8">题目描述</h2><p><a href="https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/">28. 找出字符串中第一个匹配项的下标</a></p><h2 id="代码实现-v5">代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//28. 找出字符串中第一个匹配项的下标</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindTheIndexOfTheFirstOccurrenceInAString28</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Solution</span>().strStr(<span class="string">&quot;aabaabaafa&quot;</span>, <span class="string">&quot;aabaaf&quot;</span>));<span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strStr</span><span class="params">(String haystack, String needle)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (needle.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[needle.length()];</span><br><span class="line">    getNext(needle, next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; haystack.length(); i++) &#123;</span><br><span class="line">    <span class="keyword">while</span> ( j &gt; <span class="number">0</span> &amp;&amp; needle.charAt(j) != haystack.charAt(i)) j = next[j - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (haystack.charAt(i) == needle.charAt(j)) j++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (j == needle.length()) <span class="keyword">return</span> i - needle.length() + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">getNext</span><span class="params">(String s ,<span class="type">int</span>[] next)</span> &#123;</span><br><span class="line">    </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">    <span class="comment">//下面这个while我还没有理解透彻，但是能写出来</span></span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s.charAt(i) != s.charAt(j)) j = next[j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> (s.charAt(i) == s.charAt(j)) j++;</span><br><span class="line">    next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="个人总结-v9">个人总结</h2><p>KMP</p><h3 id="前后缀">前后缀</h3><p>==<strong>前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串</strong>。==</p><p>==<strong>后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</strong>。==</p><h3 id="为什么跳前缀表哪里？">为什么跳前缀表哪里？</h3><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230402160635688.png" alt="image-20230402160635688"></p><p>图中的<code>加粗黑字</code>对于理解为什么<code>f</code>不对付跳到<code>2</code>那个地方的<code>B</code>有很大的帮助。</p><h3 id="整个流程的理解">整个流程的理解</h3><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230402162838624.png" alt="image-20230402162838624"></p><p>前缀表：相同前后缀的强度（&lt;= 当前）</p><h3 id="我们这里的实现">我们这里的实现</h3><ol><li>是 KMP</li><li>同时 next数组直接使用前缀表</li></ol><p>我觉得这个处理是很好的一个解决途径。</p><h3 id="我的困惑">我的困惑</h3><p>==那个求 next()哪里的while()跳回next数组的上一个。==</p>]]></content>
    
    
    <summary type="html">KMP算法第一个实例。多写几遍，看到就写一遍。</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
