<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMC_Blog</title>
  
  
  <link href="http://lmc.pub/atom.xml" rel="self"/>
  
  <link href="http://lmc.pub/"/>
  <updated>2023-04-11T22:41:40.110Z</updated>
  <id>http://lmc.pub/</id>
  
  <author>
    <name>LMC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【JavaSE】length相关</title>
    <link href="http://lmc.pub/posts/2926284436.html"/>
    <id>http://lmc.pub/posts/2926284436.html</id>
    <published>2023-04-11T22:40:25.000Z</published>
    <updated>2023-04-11T22:41:40.110Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总结-v9">总结</h2><p>length：数组的属性</p><p>length()：String的方法</p><p>size()：集合的方法</p>]]></content>
    
    
    <summary type="html">【JavaSE】length相关</summary>
    
    
    
    <category term="Java" scheme="http://lmc.pub/categories/Java/"/>
    
    <category term="JavaSE" scheme="http://lmc.pub/categories/Java/JavaSE/"/>
    
    
    <category term="JavaSE" scheme="http://lmc.pub/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>【JavaSE】Java命名规范</title>
    <link href="http://lmc.pub/posts/1918387145.html"/>
    <id>http://lmc.pub/posts/1918387145.html</id>
    <published>2023-04-11T13:38:16.000Z</published>
    <updated>2023-04-11T22:21:51.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="规则">规则</h2><ol><li>不可数字开头</li><li>不能包含空格</li><li>不能直接用保留字和关键字</li><li>可以用这些：26个英文字母大小写，0~9，<code>_</code> 和 <code>$</code>。</li></ol><h2 id="规范">规范</h2><ol><li>包名：都小写</li><li>类名，接口名：大驼峰（全首字母大写）</li><li>方法名，变量名：小驼峰（第一个首字母小写）</li><li>常量：全大写，<code>_</code>连接。</li></ol>]]></content>
    
    
    <summary type="html">【JavaSE】Java命名规范</summary>
    
    
    
    <category term="Java" scheme="http://lmc.pub/categories/Java/"/>
    
    <category term="JavaSE" scheme="http://lmc.pub/categories/Java/JavaSE/"/>
    
    
    <category term="JavaSE" scheme="http://lmc.pub/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>【算法】完全二叉树的节点个数222</title>
    <link href="http://lmc.pub/posts/862771459.html"/>
    <id>http://lmc.pub/posts/862771459.html</id>
    <published>2023-04-11T12:12:56.000Z</published>
    <updated>2023-04-12T00:30:29.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v3">描述</h2><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/">222. 完全二叉树的节点个数 - 力扣（Leetcode）</a></p><h2 id="分析-v3">分析</h2><h2 id="实现-v3">实现</h2><h2 id="总结-v3">总结</h2>]]></content>
    
    
    <summary type="html">【算法】完全二叉树的节点个数222</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二叉树的最小深度111</title>
    <link href="http://lmc.pub/posts/53531040.html"/>
    <id>http://lmc.pub/posts/53531040.html</id>
    <published>2023-04-11T12:07:38.000Z</published>
    <updated>2023-04-11T12:15:50.339Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v2">描述</h2><p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/">111. 二叉树的最小深度 - 力扣（Leetcode）</a></p><h2 id="分析-v2">分析</h2><h2 id="实现-v2">实现</h2><h2 id="总结-v2">总结</h2>]]></content>
    
    
    <summary type="html">【算法】二叉树的最小深度111</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二叉树的最大深度104</title>
    <link href="http://lmc.pub/posts/686088195.html"/>
    <id>http://lmc.pub/posts/686088195.html</id>
    <published>2023-04-11T12:07:10.000Z</published>
    <updated>2023-04-11T12:08:15.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述">描述</h2><p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度 - 力扣（Leetcode）</a></p><h2 id="分析">分析</h2><h2 id="实现">实现</h2><h2 id="总结">总结</h2>]]></content>
    
    
    <summary type="html">【算法】二叉树的最大深度104</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】对称二叉树101</title>
    <link href="http://lmc.pub/posts/4038420375.html"/>
    <id>http://lmc.pub/posts/4038420375.html</id>
    <published>2023-04-11T12:05:02.000Z</published>
    <updated>2023-04-12T00:29:41.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v13">描述</h2><p><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树 - 力扣（Leetcode）</a></p><h2 id="分析-v10">分析</h2><h2 id="实现-v11">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//101. 对称二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SymmetricTree101</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">3</span>&#125;);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Solution</span>().isSymmetric(root)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;这是个对称二叉树&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *二叉树的构建</span></span><br><span class="line"><span class="comment"> * int[] -&gt; 二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTreeHelper</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[index]);</span><br><span class="line"></span><br><span class="line">        node.left = buildTreeHelper(arr, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        node.right = buildTreeHelper(arr, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="comment">//递归解决</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compare(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">compare</span><span class="params">(TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line">    <span class="comment">//含null的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不含null的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left.val != right.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">bOuter</span> <span class="operator">=</span> compare(left.left, right.right);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">bInner</span> <span class="operator">=</span> compare(left.right, right.left);</span><br><span class="line">    <span class="keyword">return</span> bOuter &amp;&amp; bInner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双向队列解决 offer poll</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric2</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    deque.offerFirst(root.left);</span><br><span class="line">    deque.offerLast(root.right);</span><br><span class="line">    TreeNode leftNode;</span><br><span class="line">    TreeNode rightNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!deque.isEmpty())&#123;</span><br><span class="line">    leftNode = deque.pollFirst();</span><br><span class="line">    rightNode = deque.pollLast();</span><br><span class="line">    <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode ==  <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    deque.offerFirst(leftNode.left);<span class="comment">//左外</span></span><br><span class="line">    deque.offerFirst(leftNode.right);<span class="comment">//左内</span></span><br><span class="line">    deque.offerLast(rightNode.right);<span class="comment">//右外</span></span><br><span class="line">    deque.offerLast(rightNode.left);<span class="comment">//右内</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//单向队列解决</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric3</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    queue.offer(root.left);</span><br><span class="line">    queue.offer(root.right);</span><br><span class="line">    TreeNode leftNode;</span><br><span class="line">    TreeNode rightNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">    leftNode = queue.poll();</span><br><span class="line">    rightNode = queue.poll();</span><br><span class="line">    <span class="keyword">if</span> (leftNode == <span class="literal">null</span> &amp;&amp; rightNode ==  <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftNode == <span class="literal">null</span> || rightNode == <span class="literal">null</span> || leftNode.val != rightNode.val) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    queue.offer(leftNode.left);<span class="comment">//左外</span></span><br><span class="line">    queue.offer(rightNode.right);<span class="comment">//右外</span></span><br><span class="line">    queue.offer(leftNode.right);<span class="comment">//左内</span></span><br><span class="line">    queue.offer(rightNode.left);<span class="comment">//右内</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;<span class="built_in">this</span>.val = val;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val, TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line"><span class="built_in">this</span>.left = left;</span><br><span class="line"><span class="built_in">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v13">总结</h2>]]></content>
    
    
    <summary type="html">【算法】对称二叉树101</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】反转二叉树226</title>
    <link href="http://lmc.pub/posts/2610638650.html"/>
    <id>http://lmc.pub/posts/2610638650.html</id>
    <published>2023-04-11T12:00:12.000Z</published>
    <updated>2023-04-11T23:07:54.776Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v12">描述</h2><p><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树 - 力扣（Leetcode）</a></p><h2 id="分析-v9">分析</h2><p>DFS的前序是最方便的</p><h2 id="实现-v10">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//226.翻转二叉树</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InvertBinaryTree226</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> buildTree(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;);</span><br><span class="line">root = <span class="keyword">new</span> <span class="title class_">Solution</span>().invertTree(root);</span><br><span class="line">levelOrderTraversal(root);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *二叉树的构建</span></span><br><span class="line"><span class="comment"> * int[] -&gt; 二叉树</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> buildTreeHelper(arr, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeNode <span class="title function_">buildTreeHelper</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= arr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(arr[index]);</span><br><span class="line"></span><br><span class="line">        node.left = buildTreeHelper(arr, <span class="number">2</span> * index + <span class="number">1</span>);</span><br><span class="line">        node.right = buildTreeHelper(arr, <span class="number">2</span> * index + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *层序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">levelOrderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            System.out.print(node.val + <span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">invertTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    invert(root);</span><br><span class="line">    invert(root.left);</span><br><span class="line">    invert(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">invert</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root.left;</span><br><span class="line">    root.left = root.right;</span><br><span class="line">    root.right = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;<span class="built_in">this</span>.val = val;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val, TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line"><span class="built_in">this</span>.left = left;</span><br><span class="line"><span class="built_in">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v12">总结</h2>]]></content>
    
    
    <summary type="html">非常常考的一道题目</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二叉树遍历</title>
    <link href="http://lmc.pub/posts/7214594.html"/>
    <id>http://lmc.pub/posts/7214594.html</id>
    <published>2023-04-11T11:22:56.000Z</published>
    <updated>2023-04-11T23:18:54.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目">题目</h2><p><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历 - 力扣（Leetcode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历 - 力扣（Leetcode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-preorder-traversal/">144. 二叉树的前序遍历 - 力扣（Leetcode）</a></p><p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历 - 力扣（Leetcode）</a></p><h2 id="二叉树遍历方式">二叉树遍历方式</h2><ul><li>深度优先遍历<ul><li>前序（迭代，递归）</li><li>中序（迭代，递归）</li><li>后序（迭代，递归）</li></ul></li><li>广度优先遍历<ul><li>层次遍历（迭代）</li></ul></li></ul><p>怎么看前中后：父节点在哪就是什么序。</p><p>深度遍历：一般都是用递归。用栈也可以。</p><p>广度遍历：用队列比较多。</p><h2 id="二叉树遍历">二叉树遍历</h2><h3 id="深度优先">深度优先</h3><p>用栈实现first，递归实现大家都会。</p><p>下次直接练习统一迭代实现吧。</p><h4 id="递归实现">递归实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="comment">//前序</span></span><br><span class="line">     <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    preorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">preorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span>&#123;</span><br><span class="line">    <span class="comment">//迭代结束点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    res.add(root.val);</span><br><span class="line">    preorder(root.left, res);</span><br><span class="line">    preorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    inorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">inorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span>&#123;</span><br><span class="line">    <span class="comment">//迭代结束点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    inorder(root.left, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    inorder(root.right, res);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//后序</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    postorder(root, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">postorder</span><span class="params">(TreeNode root, List&lt;Integer&gt; res)</span>&#123;</span><br><span class="line">    <span class="comment">//迭代结束点</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//后序遍历</span></span><br><span class="line">    postorder(root.left, res);</span><br><span class="line">    postorder(root.right, res);</span><br><span class="line">    res.add(root.val);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="栈实现">栈实现</h4><p>栈实现(这个有点难度)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack  = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">temp</span> <span class="operator">=</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(temp != <span class="literal">null</span> || !stack.isEmpty())&#123;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">    stack.push(temp);</span><br><span class="line">    temp = temp.left;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    temp = stack.pop();</span><br><span class="line">    res.add(temp.val);</span><br><span class="line">    temp = temp.right;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack  = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//栈没有空就继续干</span></span><br><span class="line">    temp = stack.pop();</span><br><span class="line">    res.add(temp.val);</span><br><span class="line">    <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">    stack.push(temp.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">    stack.push(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//栈</span></span><br><span class="line">    Stack&lt;TreeNode&gt; stack  = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//栈没有空就继续干</span></span><br><span class="line">    temp = stack.pop();</span><br><span class="line">    res.add(temp.val);</span><br><span class="line">    <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) &#123;</span><br><span class="line">    stack.push(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) &#123;</span><br><span class="line">    stack.push(temp.left);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="统一迭代实现">统一迭代实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution3</span> &#123;</span><br><span class="line">    <span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode temp;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    temp = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) stack.push(temp.right);</span><br><span class="line">    stack.push(temp);</span><br><span class="line">    stack.push(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) stack.push(temp.left);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    temp = stack.pop();</span><br><span class="line">    res.add(temp.val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode temp;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    temp = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">    stack.push(temp);</span><br><span class="line">    stack.push(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) stack.push(temp.right);</span><br><span class="line">    <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) stack.push(temp.left);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    temp = stack.pop();</span><br><span class="line">    res.add(temp.val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line">    TreeNode temp;</span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">    temp = stack.pop();</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) stack.push(temp.right);</span><br><span class="line">    <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) stack.push(temp.left);</span><br><span class="line">    stack.push(temp);</span><br><span class="line">    stack.push(<span class="literal">null</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    temp = stack.pop();</span><br><span class="line">    res.add(temp.val);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>就是父节点后面要个null，记住规则然后知道了就很好模仿。</p><h3 id="广度优先">广度优先</h3><p>这个多写几遍就会了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="comment">//返回的ret</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ret = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="comment">//安全性校验</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列</span></span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;TreeNode&gt;();</span><br><span class="line">    <span class="comment">//让root直接入队列</span></span><br><span class="line">    que.offer(root);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">    <span class="comment">//构建这层的List</span></span><br><span class="line">    List&lt;Integer&gt; itemList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> que.size();</span><br><span class="line">    <span class="comment">//临时工TreeNode节点</span></span><br><span class="line">    TreeNode temp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="comment">//拿出队列的第一个</span></span><br><span class="line">    temp = que.poll();</span><br><span class="line">    <span class="comment">//给到这层的那个itemList</span></span><br><span class="line">    itemList.add(temp.val);</span><br><span class="line">    <span class="comment">//补充这个的左右两个</span></span><br><span class="line">    <span class="keyword">if</span> (temp.left != <span class="literal">null</span>) que.offer(temp.left);</span><br><span class="line">    <span class="keyword">if</span> (temp.right != <span class="literal">null</span>) que.offer(temp.right);</span><br><span class="line">    &#125;</span><br><span class="line">    ret.add(itemList);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">基本功。先栈后递归</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二叉树基础</title>
    <link href="http://lmc.pub/posts/1031501492.html"/>
    <id>http://lmc.pub/posts/1031501492.html</id>
    <published>2023-04-10T22:26:15.000Z</published>
    <updated>2023-04-11T11:26:32.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉树种类">二叉树种类</h2><ol><li><p>满二叉树：如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806185805576.png" alt="img"></p><p>深度为k，有2^k-1个节点</p></li><li><p>完全二叉树：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。</p><p><img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920221638903.png" alt="img"></p></li><li><p>二叉搜索树<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190304693.png" alt="img"></p><p>数值大小：左 &lt; 父 &lt; 右</p></li><li><p>平衡二叉搜索树（AVL树）。它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200806190511967.png" alt="img"></p></li></ol><h2 id="二叉树的存储方式">二叉树的存储方式</h2><p>链式：指针<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2020092019554618.png" alt="img"></p><p>顺序：数组<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20200920200429452.png" alt="img"></p><p><strong>如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。</strong></p><h2 id="二叉树定义">二叉树定义</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> data)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> data, TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.data = data;</span><br><span class="line"><span class="built_in">this</span>.left = left;</span><br><span class="line"><span class="built_in">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">种类，存储方式，定义</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【计网】HTTP基础</title>
    <link href="http://lmc.pub/posts/277348140.html"/>
    <id>http://lmc.pub/posts/277348140.html</id>
    <published>2023-04-09T13:27:25.000Z</published>
    <updated>2023-04-10T14:26:45.992Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HTTP-1-0">HTTP/1.0</h2><p>非持续连接：</p><p>请求一个文件的时候就去建立TCP连接，收到响应马上就关闭。</p><h2 id="HTTP-1-1">HTTP/1.1</h2><p>持续连接：</p><p>请求文件的时候建立TCP连接，然后完成一个文件访问响应之后还是可以继续用的。</p><p>前提是请求的文档全在同一个服务器上。</p><p>流水线方式工作：再还没有respon 的时候就发好几个请求报文，然后批量回复。</p><h2 id="HTTP报文格式">HTTP报文格式</h2><h3 id="请求报文">请求报文</h3><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409213259942.png" alt="image-20230409213259942"></p><p>举例：</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409213423918.png" alt="image-20230409213423918"></p><h3 id="响应报文">响应报文</h3><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409213834822.png" alt="image-20230409213834822"></p><h2 id="HTTP请求方法">HTTP请求方法</h2><p>GET：请求URL标志的文档</p><p>HEAD：请求URL标志的文档的首部</p><p>POST：向服务器发送数据</p><p>PUT：在指明的URL下存储一个文档</p><p>DELETE：删除URL标志的文档</p><p>CONNECT：用于代理服务器</p><p>OPTIONS：请求一些选项信息</p><p>TRACE：用来进行环回测试</p><p>PATCH：对PUT方法的补充，用来对已知资源进行局部更新</p><hr><h2 id="常见状态码">常见状态码</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409213859326.png" alt="image-20230409213859326"></p><h2 id="常见状态行">常见状态行</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409213940025.png" alt="image-20230409213940025"></p><h2 id="Cookie">Cookie</h2><p>在服务器上记录用户信息</p><p>让服务器能够识别用户</p><p>是一种对无状态的HTTP进行状态化的技术</p><p>工作原理</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409214401664.png" alt="image-20230409214401664"></p>]]></content>
    
    
    <summary type="html">【计网】HTTP基础</summary>
    
    
    
    <category term="计算机基础" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计网" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://lmc.pub/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【计网】TCP报文段首部格式</title>
    <link href="http://lmc.pub/posts/1870036843.html"/>
    <id>http://lmc.pub/posts/1870036843.html</id>
    <published>2023-04-09T08:58:35.000Z</published>
    <updated>2023-04-09T13:25:34.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v18">描述</h2><blockquote><p>TCP 报文格式?</p></blockquote><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409171134135.png" alt="image-20230409171134135"></p><p>源端口：发送方进程的端口</p><p>目的端口：接收方进程的端口</p><p>seq序号：数据偏移部分第一个序号</p><p>ack确认号：这个序号之前的字节我都接受了 + 请给我发从这个序号之后的字节</p><p>数据偏移：TCP首部有多长</p><p>保留：没东西</p><p>窗口：发送的一方自己的接受窗口大小</p><p>校验和：</p><p>URG：配合紧急指针用的，让发送的那段数据不用缓存直接给上方进程</p><p>SYN：同步序列号</p><p>ACK：确认报文段</p><p>FIN：结束报文段</p><p>RST：超时重传的那个</p><hr><p>参考</p><blockquote><ul><li>源端口(Source Port)和目的端口(Destination Port)：每个16位，用于标识发送方和接收方的应用程序。</li><li>序列号(Sequence Number)和确认号(Acknowledgment Number)：每个32位，序列号表示本次传输的数据的第一个字节的序号，确认号表示期望下一次接收到的字节的序号。</li><li>数据偏移(Data Offset)：4位，表示TCP头部的长度，单位为32位字。最小值为5，最大值为15。</li><li>保留位(Reserved)：6位，保留未使用，必须为0。</li><li>控制位(Flags)：6位，用于标识TCP报文的类型。U表示紧急，A表示确认，P表示推送，R表示重置，S表示同步，F表示结束。</li><li>窗口(Window)：16位，表示接收方还能接收多少字节的数据。</li><li>校验和(Checksum)：16位，用于检测TCP报文是否有错。</li><li>紧急指针(Urgent Pointer)：16位，用于标识紧急数据的边界。</li><li>选项(Options)：长度可变，用于传递额外的信息，如最大报文长度、时间戳等。</li><li>填充(Padding)：长度可变，用于填充选项字段，使TCP头部的长度为32位的倍数。</li><li>数据(Data)：长度可变，表示应用层传输的数据。</li></ul></blockquote>]]></content>
    
    
    <summary type="html">【计网】TCP报文段首部格式</summary>
    
    
    
    <category term="计算机基础" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计网" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://lmc.pub/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【计网】三报文握手，四报文挥手</title>
    <link href="http://lmc.pub/posts/2090942918.html"/>
    <id>http://lmc.pub/posts/2090942918.html</id>
    <published>2023-04-09T08:27:48.000Z</published>
    <updated>2023-04-09T13:23:01.964Z</updated>
    
    <content type="html"><![CDATA[<h2 id="三握手">三握手</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409163503218.png" alt="image-20230409163503218"></p><p>SYN：同步位 （这个为1，不能携带数据。但是消耗一个序号）</p><p>ACK：确认位</p><p>seq：序号</p><p>ack：确认号</p><p>为什么非要三握手？两握手行不行？</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409163744632.png" alt="image-20230409163744632"></p><h2 id="四挥手">四挥手</h2><p>过程</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409164518495.png" alt="image-20230409164518495"></p><p>客户端为什么还有时间等待，而不是发送最后一个确认报文段直接关闭？</p><blockquote><p>为什么 TIME WAIT 需要等待 2MSL?</p></blockquote><p>1.<img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409164709039.png" alt="image-20230409164709039"></p><p>2.是本次连接持续时间内产生的所有报文段全部从网络中消失，这样新的、TCP连接就不会有旧的连接报文段。</p><h2 id="保活计时器">保活计时器</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230409165011702.png" alt="image-20230409165011702"></p>]]></content>
    
    
    <summary type="html">【计网】三报文握手，四报文挥手</summary>
    
    
    
    <category term="计算机基础" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计网" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://lmc.pub/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>【算法】前k个高频元素347</title>
    <link href="http://lmc.pub/posts/108615348.html"/>
    <id>http://lmc.pub/posts/108615348.html</id>
    <published>2023-04-09T05:51:30.000Z</published>
    <updated>2023-04-10T22:15:22.341Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v11">描述</h2><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/">前k个高频元素347</a></p><h2 id="分析-v8">分析</h2><h2 id="实现-v9">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//347. 前 K 个高频元素</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKFrequentElements347</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : <span class="keyword">new</span> <span class="title class_">Solution</span>().topKFrequent(arr,<span class="number">2</span>)) &#123;</span><br><span class="line">System.out.print(item + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">       <span class="comment">//统计频率</span></span><br><span class="line">Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : nums) &#123;</span><br><span class="line">map.put(item,map.getOrDefault(item,<span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">PriorityQueue&lt;<span class="type">int</span>[]&gt; pq = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((pair1,pair2) -&gt; pair2[<span class="number">1</span>] - pair1[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet()) &#123;</span><br><span class="line">pq.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出k</span></span><br><span class="line"><span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k ; i++) &#123;</span><br><span class="line">res[i] = pq.poll()[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v11">总结</h2><p>主要是集合那些方法不太熟悉了</p>]]></content>
    
    
    <summary type="html">优先级队列</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】滑动窗口最大值239</title>
    <link href="http://lmc.pub/posts/1607998336.html"/>
    <id>http://lmc.pub/posts/1607998336.html</id>
    <published>2023-04-09T05:50:42.000Z</published>
    <updated>2023-04-10T22:15:03.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v14">描述</h2><p><a href="https://leetcode.cn/problems/sliding-window-maximum/">滑动窗口最大值239</a></p><h2 id="分析-v11">分析</h2><h2 id="实现-v12">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//239. 滑动窗口最大值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowMaximum239</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> item : <span class="keyword">new</span> <span class="title class_">Solution</span>().maxSlidingWindow(arr,k)) &#123;</span><br><span class="line">System.out.print(item + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">MyQueue</span> <span class="variable">myQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - k + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先进k个队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    myQueue.add(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    res[temp++] = myQueue.peek();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> k; j &lt; nums.length; j++) &#123;</span><br><span class="line">    myQueue.poll(nums[j - k]);</span><br><span class="line">    myQueue.add(nums[j]);</span><br><span class="line">    res[temp++] = myQueue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//poll</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">poll</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!deque.isEmpty() &amp;&amp; deque.peek() == num) &#123;</span><br><span class="line">deque.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//add</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; num &gt; deque.getLast()) deque.removeLast();</span><br><span class="line">deque.add(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//peek</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> deque.peek();</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v14">总结</h2><p>主要是一个思想，你领悟到了没有？</p><p><strong>队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的。</strong></p><p><strong>单调队列，即单调递减或单调递增的队列。</strong></p>]]></content>
    
    
    <summary type="html">单调队列/第一个hard</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】逆波兰表达式求值150</title>
    <link href="http://lmc.pub/posts/2607567793.html"/>
    <id>http://lmc.pub/posts/2607567793.html</id>
    <published>2023-04-09T05:50:10.000Z</published>
    <updated>2023-04-10T06:10:30.192Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v17">描述</h2><p><a href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/">150. 逆波兰表达式求值 - 力扣（Leetcode）</a></p><h2 id="分析-v14">分析</h2><p>很简单，一句话。</p><p>遇到数字就怼进去。</p><p>遇到运算符就把栈最上面两个做运算然后结果入栈。</p><p>如此往复。</p><h2 id="实现-v15">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//150. 逆波兰表达式求值</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EvaluateReversePolishNotation150</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">String[] stringArry = &#123;<span class="string">&quot;2&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;+&quot;</span>,<span class="string">&quot;3&quot;</span>,<span class="string">&quot;*&quot;</span>&#125;;</span><br><span class="line">System.out.println(<span class="string">&quot;res = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Solution</span>().evalRPN(stringArry));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">evalRPN</span><span class="params">(String[] tokens)</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String item: tokens) &#123;</span><br><span class="line">    <span class="keyword">if</span> (item.equals(<span class="string">&quot;+&quot;</span>)) &#123;</span><br><span class="line">    stack.push(stack.pop() + stack.pop());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;-&quot;</span>)) &#123;</span><br><span class="line">    stack.push(-stack.pop() + stack.pop());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">    stack.push(stack.pop() * stack.pop());</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item.equals(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">temp1</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">temp2</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">    stack.push(temp2 / temp1);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    stack.push(Integer.valueOf(item));</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v17">总结</h2><p>其实中缀表达式是给人看的，计算机更加喜欢后缀表达式。</p>]]></content>
    
    
    <summary type="html">【算法】逆波兰表达式求值150</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】删除字符串中的所有相邻重复项1047</title>
    <link href="http://lmc.pub/posts/2327252199.html"/>
    <id>http://lmc.pub/posts/2327252199.html</id>
    <published>2023-04-09T05:49:42.000Z</published>
    <updated>2023-04-09T09:40:26.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v10">描述</h2><p><a href="https://leetcode.cn/problems/remove-all-adjacent-duplicates-in-string/description/">1047. 删除字符串中的所有相邻重复项 - 力扣（Leetcode）</a></p><h2 id="分析-v7">分析</h2><h2 id="实现-v8">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Deque;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1047. 删除字符串中的所有相邻重复项</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveAllAdjacentDuplicatesInString1047</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="keyword">new</span> <span class="title class_">Solution</span>().removeDuplicates(<span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in).nextLine()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//栈法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    ArrayDeque&lt;Character&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> item : s.toCharArray())&#123;</span><br><span class="line">    <span class="keyword">if</span> (res.isEmpty() || item != res.peek()) &#123;</span><br><span class="line">    res.push(item);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    res.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">r</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!res.isEmpty())&#123;</span><br><span class="line">    r = res.pop() + r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//双指针法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicates</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span>[] res = s.toCharArray();</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; s.length())&#123;</span><br><span class="line">    res[slow] = res[fast];</span><br><span class="line">    <span class="keyword">if</span> (slow &gt; <span class="number">0</span> &amp;&amp; res[slow] == res[slow - <span class="number">1</span>]) &#123;</span><br><span class="line">    slow--;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    slow++;</span><br><span class="line">    &#125;</span><br><span class="line">    fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(res, <span class="number">0</span>, slow);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v10">总结</h2><p>以后用双指针法，更加高效。</p>]]></content>
    
    
    <summary type="html">不能用ArrayDeque,用双指针更加高效。</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】有效的括号20</title>
    <link href="http://lmc.pub/posts/4071001534.html"/>
    <id>http://lmc.pub/posts/4071001534.html</id>
    <published>2023-04-09T05:48:48.000Z</published>
    <updated>2023-04-09T09:40:26.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v15">描述</h2><p><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号 - 力扣（Leetcode）</a></p><h2 id="分析-v12">分析</h2><p>先分析有哪几种<code>非有效的括号</code></p><ol><li>左边多了<img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/2020080915505387.png" alt="括号匹配1"></li><li>左右不匹配的<img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/20200809155107397.png" alt="括号匹配2"></li><li>右边多了<img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/20200809155115779.png" alt="括号匹配3"></li></ol><h2 id="实现-v13">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有效的括号20</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ValidParentheses20</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">new</span> <span class="title class_">Solution</span>().isValid(input.nextLine())) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValid</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s.length() % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//字符串为奇数，坑定不会yes</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> item : s.toCharArray())&#123;</span><br><span class="line">    <span class="keyword">if</span> (item == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">    stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item ==<span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">    stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (item == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">    stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (stack.isEmpty() || stack.peek() != item)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v15">总结</h2>]]></content>
    
    
    <summary type="html">对称匹配类题目很适合用栈</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【Bug】java使用了未经检查或者不安全的操作</title>
    <link href="http://lmc.pub/posts/3287331760.html"/>
    <id>http://lmc.pub/posts/3287331760.html</id>
    <published>2023-04-03T23:42:42.000Z</published>
    <updated>2023-04-09T09:40:26.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v6">描述</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230404074311479.png" alt="image-20230404074311479"></p><p>早上起来刷算法的时候，在DOS下面编译java文件的时候突然问发生的。</p><h2 id="分析-v6">分析</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230404074408894.png" alt="image-20230404074408894"></p><p>当时在定义的时候，后面没有图上这两个泛型。</p><h2 id="解决-v3">解决</h2><ol><li>加上泛型</li><li>在main方法面前加@SuppressWarnings(“unchecked”)</li></ol><h2 id="总结-v6">总结</h2><p>JavaSE基础语法要一直熟悉记得，不然就容易犯一些小错误。</p>]]></content>
    
    
    <summary type="html">犯了两次了</summary>
    
    
    
    <category term="Bug" scheme="http://lmc.pub/categories/Bug/"/>
    
    
    <category term="Bug" scheme="http://lmc.pub/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>【算法】用栈实现队列232</title>
    <link href="http://lmc.pub/posts/2605004311.html"/>
    <id>http://lmc.pub/posts/2605004311.html</id>
    <published>2023-04-03T23:04:24.000Z</published>
    <updated>2023-04-09T09:40:26.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v16">描述</h2><p><a href="https://leetcode.cn/problems/implement-queue-using-stacks/description/">用栈实现队列232</a></p><h2 id="分析-v13">分析</h2><h2 id="实现-v14">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//用栈实现队列232</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ImplementQueueUsingStacks232</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">input</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"></span><br><span class="line"><span class="type">MyQueue</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyQueue</span>();</span><br><span class="line">System.out.print(<span class="string">&quot;请输入入队数字：&quot;</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> input.nextInt(); </span><br><span class="line">obj.push(x);</span><br><span class="line">obj.push(<span class="number">66</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">param_2</span> <span class="operator">=</span> obj.pop();</span><br><span class="line">System.out.println(<span class="string">&quot;\npop为： &quot;</span> + param_2);</span><br><span class="line"><span class="type">int</span> <span class="variable">param_3</span> <span class="operator">=</span> obj.peek();</span><br><span class="line">System.out.println(<span class="string">&quot;peek为： &quot;</span> + param_3);</span><br><span class="line"><span class="type">boolean</span> <span class="variable">param_4</span> <span class="operator">=</span> obj.empty();</span><br><span class="line">System.out.println(<span class="string">&quot;链表是否为空：&quot;</span> + param_4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line">Stack&lt;Integer&gt; stackIn;</span><br><span class="line">Stack&lt;Integer&gt; stackOut;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    stackIn.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    in2Out();</span><br><span class="line">    <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">    in2Out();</span><br><span class="line">    <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">empty</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> stackOut.isEmpty() &amp;&amp; stackIn.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">in2Out</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!stackOut.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!stackIn.isEmpty())&#123;</span><br><span class="line">    stackOut.push(stackIn.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v16">总结</h2>]]></content>
    
    
    <summary type="html">主要是两个栈来配合这个队列</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【计网】TCP是怎么实现可靠传输的？</title>
    <link href="http://lmc.pub/posts/874385989.html"/>
    <id>http://lmc.pub/posts/874385989.html</id>
    <published>2023-04-03T12:39:29.000Z</published>
    <updated>2023-04-09T09:40:26.392Z</updated>
    
    <content type="html"><![CDATA[<h2 id="官方答案">官方答案</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403204257995.png" alt="image-20230403204257995"></p><h2 id="知识储备">知识储备</h2><h3 id="TCP流量控制">TCP流量控制</h3><blockquote><p>为什么要有 TCP 流量控制？</p></blockquote><p>因为在通信的时候，接收方的接受能力有限。如果发送方一直发，接收方吃不下，接受处理来不及就会造成数据丢失。</p><p>所以就想出来这么一个法子：当一个主机通过 TCP 协议向另一个主机发送数据时候，接受方就会开启一个<code>接受滑动窗口</code>。并由此对发送方的发送策略做出一定的信号进行干涉。</p><blockquote><p>核心的一些技术是什么？</p></blockquote><p><code>滑动窗口，超时重传，零窗口探测报文</code>。</p><blockquote><p>具体过程</p></blockquote><p>首先发送方通过三报文握手和接收方建立连接。</p><p>然后这时候，接收方就产生一个自己的接受窗口。并把这个窗口的大小传回给发送方。</p><p>然后发送方就会把这个值设置为自己的发送窗口。</p><p>然后就把应用程序给的数据分成不同的小组，先发一个小组给接收方，同时每发送一个报文小组就会开启超时重传。</p><p>也就是如果没有在规定时间内接受到这个已发送的报文 respon 就会重新发送这个报文小组。</p><p>这个发送动作会一直存在，直到发送窗口里的报文小组全发出去了。</p><p>接收方接受了这些报文后，会根据自己的缓存实际情况去调整自己的接受窗口大小。</p><p>并会就就接受到的最后一个小组发送一个收到确认报文端。里面会带着新的窗口大小。</p><p>接受方接收到这个respon之后会把发送窗口向后移动，把已经接受的小组移到外面去并删除这些小组。</p><p>然后就调整自己的发送窗口和接受窗口一样大。</p><p>然后就会重复上面这个过程。这之中如果一个发送小组的respon一直不来，等到这个小组的超时重传到时间了，就会重新发送这个小组。</p><p>如果接受窗口调整成0了，那在发送窗口设置成0了之后。发送方会每隔一段时间（零窗口探测报文的超时重传,==也就是持续计时器==）就发送一个只有一个报文的零窗口探测报文，接收方接收到了就立刻发送此时此刻自己的接受窗口给对面。</p><blockquote><p>rwnd：这个接收方返回自己接受窗口的携带变量</p></blockquote><h3 id="TCP的拥塞控制">TCP的拥塞控制</h3><blockquote><p>什么是拥塞？为什么要进行拥塞控制？</p></blockquote><p>拥塞就是一个网络资源的提供是有限的，但是一段时间内却有很多人去请求。导致该网络资源无法再提供给申请者。</p><p>因为实际网络情况中，一个网络通道中随着加入的报文分组越来越多（也就是随着网络负载越来越大），实际返回回来出网络通道的数据（吞吐量）是呈急剧式下跌的，最后会直接不再返回数据。也就直接死锁了。</p><p>对应到现实生活就是APP上有一个资源，比如是一张图片。本来正常的不拥塞的网络，大家一访问就会立马看到显示到手机屏幕上。但是随着想看这个图片的人越来越多，发送到后端服务器的请求越来越多，也就是网络负载增大。服务器返回图片就会越来越慢，从用户点击要看图片到最后加载出来的加载时间越来越长。有些用户就会申请不到图片（丢包率上升。）最终只要网络请求足够多，网络负载达到一定层度，服务器和app之间的通道会直接完全阻塞。不会返回任何数据。</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403211357823.png" alt="image-20230403211357823"></p><p>输入负载：单位时间内给网络通道的分组数量</p><p>吞吐量：单位时间内网络通道出来的分组数量</p><blockquote><p>讨论前提：</p><ol><li>接收方缓存够大，发送窗口只受网络拥塞影响；</li><li>发送的单位直接用完整报文单元；</li><li></li></ol></blockquote><blockquote><p>机制流程</p></blockquote><p>发送方有一个拥塞窗口，然后直接把拥塞窗口作为发送窗口。</p><p>然后拥塞窗口的值是根据网络通道拥塞程度动态变化的。</p><p>而网络拥塞程度是根据发送方是否发生超时重传来额定的。</p><p>有几个值要特别注意：</p><ol><li>慢开始门限值ssthresh</li><li>拥塞窗口cwnd</li><li>发送窗口</li></ol><blockquote><p>解决策略：四种拥塞控制算法</p></blockquote><p><strong>慢开始 + 拥塞控制</strong></p><p>下面的发送窗口 = 拥塞窗口 = 吞吐量</p><p>满开始就是刚开始的发送窗口是 1，然后每接受一个respon就 *2.成指数上升。</p><p>这里的慢指的是，发送窗口开始小，而不是发送大小增长慢。</p><p>然后当发送窗口达到慢开始门限值的时候就会启动拥塞控制，也就是发送窗口现在接受respon 每次就+1，线性增长。</p><p>如果中间发送的分组丢失，导致发送方发生超时重传就断定网络发生了拥塞。慢开始门限值直接变为当前发送窗口一半，然后发送窗口变为1。又开始慢开始算法。</p><p><strong>快重传 + 快恢复</strong></p><p>这个就是在上面的基础上，针对遇到数组丢失的情况做了一点优化。</p><p>之前是发送窗口中的东西发完了，轮到接收方respon的时候接收方顺带返回的。</p><p>现在是直接接收方接收到一个就回复确认一个，如果收到了不按照顺序到达的就直接重发上一个按序的最后一个respon。但是明确是重复标签。</p><p>然后如果发送方连续接受到了三个重复respon （）不包含正常的那个，就重发缺的哪一个</p><p>这时候就是明显拥塞了，上面这个就是快重传。</p><p>然后慢开始门限值和发送窗口统统变成当前吞吐量的一半然后直接线性拥塞控制算法上。</p><h3 id="TCP超时重传时间选择">TCP超时重传时间选择</h3><p>RTO = RTTs + 4*RTTd</p><blockquote><p>RTO：超时重传时间</p><p>RTTs：加权平均往返时间</p></blockquote><p>一般如果发生超时重传，RTO直接变大，准确点是变大 2 倍。</p><h3 id="TCP可靠传输的实现">TCP可靠传输的实现</h3><p>基于<code>以字节为单位的滑动窗口</code>来实现</p><p>rwnd ：接受窗口的大小</p><p>ack：希望收到下一个数据的序号是多少</p><p>如何描绘发送窗口的状态？</p><p>三个指针！</p><p>虽然发送窗口时接受窗口给的，但是同一时刻他两可能不一样。</p><p>因为一个有时延，二个有拥塞机制。</p><p>还有未按需到达的怎么处理，一般是先存起来，然后齐了再统一交付上层。</p>]]></content>
    
    
    <summary type="html">这个最喜欢连着上面那个【TCP与UDP的区别】连着问。</summary>
    
    
    
    <category term="计算机基础" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    <category term="计网" scheme="http://lmc.pub/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%BD%91/"/>
    
    
    <category term="计网" scheme="http://lmc.pub/tags/%E8%AE%A1%E7%BD%91/"/>
    
  </entry>
  
</feed>
