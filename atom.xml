<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LMC_Blog</title>
  
  <subtitle>MyOuterBrain</subtitle>
  <link href="http://lmc.pub/atom.xml" rel="self"/>
  
  <link href="http://lmc.pub/"/>
  <updated>2023-04-24T15:34:08.932Z</updated>
  <id>http://lmc.pub/</id>
  
  <author>
    <name>LMC</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://lmc.pub/posts/0.html"/>
    <id>http://lmc.pub/posts/0.html</id>
    <published>2023-04-24T15:33:54.553Z</published>
    <updated>2023-04-24T15:34:08.932Z</updated>
    
    <content type="html"><![CDATA[<h1>你好。我是test</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;你好。我是test&lt;/h1&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>【JavaSE】static关键字</title>
    <link href="http://lmc.pub/posts/1191355689.html"/>
    <id>http://lmc.pub/posts/1191355689.html</id>
    <published>2023-04-16T04:13:46.000Z</published>
    <updated>2023-04-24T13:10:01.590Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍-v2">介绍</h2><p>static 是 Java 里面的一个关键字，我们在开发的时候，如果希望通过不创建一个对象而访问某个类的成员就会用这个关键字去修饰。</p><h2 id="静态变量">静态变量</h2><p>也叫类变量。</p><p>只属于类，是所有这个类的对象所共享的。</p><h2 id="静态方法">静态方法</h2><p>类方法。</p><p>里面只能调用静态的变量或者方法。</p><p>想不创建对象就使用某个方法就可以在他前面加上这个关键字。</p><h2 id="静态代码块">静态代码块</h2><p>类加载的时候就直接执行</p>]]></content>
    
    
    <summary type="html">【JavaSE】static关键字</summary>
    
    
    
    <category term="Java" scheme="http://lmc.pub/categories/Java/"/>
    
    <category term="JavaSE" scheme="http://lmc.pub/categories/Java/JavaSE/"/>
    
    
    <category term="JavaSE" scheme="http://lmc.pub/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>【JavaSE】public、protected、default、private的区别</title>
    <link href="http://lmc.pub/posts/3219995583.html"/>
    <id>http://lmc.pub/posts/3219995583.html</id>
    <published>2023-04-16T02:02:31.000Z</published>
    <updated>2023-04-24T13:10:01.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="解释">解释</h2><table><thead><tr><th>访问修饰符</th><th>访问原则</th></tr></thead><tbody><tr><td>private</td><td>同类</td></tr><tr><td>默认</td><td>同包</td></tr><tr><td>protect</td><td>同包 + 子类（？）</td></tr><tr><td>public</td><td>任何地方</td></tr></tbody></table><p>注意：</p><ol><li>对于类来说，只有默认和public</li><li>上面这些都是对于类成员说的。</li><li>如果不涉及继承，应用上只有三种（private，默认/protect,public）</li><li>如果是继承访问，那个protect才有用处。</li></ol><hr><p>对象访问</p><table><thead><tr><th>修饰符</th><th>对象访问范围</th></tr></thead><tbody><tr><td>private</td><td>同类</td></tr><tr><td>默认/protect</td><td>同包</td></tr><tr><td>public</td><td>任何地方</td></tr></tbody></table><blockquote><p>也就是：在new一个对象，然后通过这个对象去调用被访问修饰符修饰过的方法的时候。</p><p>默认和protect是一样的。</p><p>就是同包以内都可以访问到。</p><p>这种访问方式，涉及子类，只用看：在不在同一个包？</p><p>默认：同包子类（Y）不同包子类（X）</p><p>protect：同包子类（Y）不同包子类（X）</p><p>在就是按那个来，这种访问方式，这两个是一致的。</p></blockquote><p>继承访问</p><table><thead><tr><th>范围</th><th>private</th><th>默认</th><th>protect</th><th>public</th></tr></thead><tbody><tr><td>同类</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>同包子类</td><td>X</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>不同包子类</td><td>X</td><td>X</td><td>Y</td><td>Y</td></tr></tbody></table><blockquote><p>这种就是，涉及继承。</p><p>访问不是new那种，而是直接一个类里面的方法直接调用你被修饰符修饰的方法。</p><p>这种情况，默认 和 protect 就不一样。</p><p>这个时候，protect 的范围成了：同包 + 所有子类。</p><p>它的所有子类可以访问，不是new一个对象，然后通过对象去访问的，而是直接访问的。</p><p>能证明这点的就是，不同包的子类。</p><p>能用这种方式，访问protect，但是访问不了默认。</p></blockquote><hr><p>这个地方，我发现很多同学其实是模糊的，根本没理解清除。</p><p>所以最后结论是：</p><p>如果是new对象那种访问，那<code>默认</code>和<code>protect</code>是一样的，==都是只能同包访问==。</p><p>如果是继承那种直接调方法访问，那<code>默认</code>还是只能访问同包的，但是<code>protect</code>可以在同包 + 所有子类访问。</p><p>所以，我们什么时候用protect？</p><p>答案是：在继承的场景下，只想让一个方法访问，同时不想让这个包以外的访问。</p>]]></content>
    
    
    <summary type="html">你果然理解错了protected访问修饰符。</summary>
    
    
    
    <category term="Java" scheme="http://lmc.pub/categories/Java/"/>
    
    <category term="JavaSE" scheme="http://lmc.pub/categories/Java/JavaSE/"/>
    
    
    <category term="JavaSE" scheme="http://lmc.pub/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>【JavaSE】JVM,JRE,JDK之间的关系</title>
    <link href="http://lmc.pub/posts/1519430248.html"/>
    <id>http://lmc.pub/posts/1519430248.html</id>
    <published>2023-04-16T01:51:08.000Z</published>
    <updated>2023-04-24T13:10:01.580Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍">介绍</h2><p>JVM：Java虚拟机。</p><p>让Java一次编译到处运行的东西。</p><hr><p>JRE：Java运行环境。</p><p>有这个才能运行Java程序。</p><p>JRE = JVM + Java核心类库</p><hr><p>JDK：Java开发工具包。</p><p>开发Java的一套工具。</p><p>JDK = JRE + Java小工具（java，javac，javaw）</p><h2 id="图解">图解</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230416100130461.png" alt="image-20230416100130461"></p>]]></content>
    
    
    <summary type="html">【JavaSE】JVM,JRE,JDK之间的关系</summary>
    
    
    
    <category term="Java" scheme="http://lmc.pub/categories/Java/"/>
    
    <category term="JavaSE" scheme="http://lmc.pub/categories/Java/JavaSE/"/>
    
    
    <category term="JavaSE" scheme="http://lmc.pub/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>【JavaSE】Java内存模型</title>
    <link href="http://lmc.pub/posts/4108216215.html"/>
    <id>http://lmc.pub/posts/4108216215.html</id>
    <published>2023-04-16T00:10:28.000Z</published>
    <updated>2023-04-24T13:10:01.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM">JVM</h2><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230416081803876.png" alt="image-20230416081803876"></p><p>分为3个部分：栈，堆，方法区。</p><hr><p><strong>方法区</strong>：类加载信息，常量，静态变量</p><p><strong>堆</strong>：放对象的地方。在JVM启动时创建。这里对象有类属性但没有类里卖弄的哪些方法。</p><p>栈：放基本数据类型。每个线程一个栈，负责方法调用存储一些局部变量，方法参数返回值什么的。方法被调用的时候就有一个栈帧，这里面放说的那些数据。然后调用方法，栈帧入栈，结束调用就出栈。</p><blockquote><p>无论是普通类型的变量还是引用类型的变量(俗称实例)，都可以作为局部变量，他们都可以出现在栈中。</p><p>只不过普通类型的变量在栈中直接保存它所对应的值，而引用类型的变量保存的是一个指向堆区的指针，通过这个指针，就可以找到这个实例在堆区对应的对象。</p><p>因此，普通类型变量只在栈区占用一块内存，而引用类型变量要在栈区和堆区各占一块内存。</p></blockquote><h2 id="什么是实例，什么是对象？">什么是实例，什么是对象？</h2><p>Object o = new Object();</p><p>左边的是实例，在栈中。</p><p>右边的是对象在堆中。</p><p>操作实例实际上是通过实例的指针间接操作对象。多个实例可以指向同一个对象。</p><h2 id="栈中的数据和堆中的数据销毁并不是同步的。">栈中的数据和堆中的数据销毁并不是同步的。</h2><p>方法一旦结束，栈中的局部变量立即销毁，但是堆中对象不一定销毁。</p><p>因为可能有其他变量也指向了这个对象，直到栈中没有变量指向堆中的对象时，它才销毁。</p><p>而且还不是马上销毁，要等垃圾回收扫描时才可以被销毁。</p><p>每一个应用程序都对应唯一的一个JVM实例，每一个JVM实例都有自己的内存区域，</p><hr><p>类的成员变量在不同对象中各不相同，都有自己的存储空间(成员变量在堆中的对象中)。而类的方法却是该类的所有对象共享的，只有一套。</p><p>对象使用方法的时候方法才被压入栈，方法不使用则不占用内存。</p><hr><p>栈有一个很重要的特性：<strong>栈中的数据可以共享</strong>。</p><p>当我们定义了int i = 40;，再定义int i0 = 40;这时候会自动检查栈中是否有40这个数据，如果有，i0会直接指向i的40，不会再添加一个新的40。</p><h2 id="常量池技术">常量池技术</h2><p>基础数据类型和基础数据类型的包装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">        objPoolTest();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">objPoolTest</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i0</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i5</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">40</span>);</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line">        Double d1=<span class="number">1.0</span>;</span><br><span class="line">        Double d2=<span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;i=i0\t&quot;</span> + (i == i0));</span><br><span class="line">        System.out.println(<span class="string">&quot;i1=i2\t&quot;</span> + (i1 == i2));</span><br><span class="line">        System.out.println(<span class="string">&quot;i1=i2+i3\t&quot;</span> + (i1 == i2 + i3));</span><br><span class="line">        System.out.println(<span class="string">&quot;i4=i5\t&quot;</span> + (i4 == i5));</span><br><span class="line">        System.out.println(<span class="string">&quot;i4=i5+i6\t&quot;</span> + (i4 == i5 + i6));    </span><br><span class="line">        System.out.println(<span class="string">&quot;d1=d2\t&quot;</span> + (d1==d2)); </span><br><span class="line">        </span><br><span class="line">        System.out.println();        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i=i0    <span class="literal">true</span></span><br><span class="line">i1=i2   <span class="literal">true</span></span><br><span class="line">i1=i2+i3        <span class="literal">true</span></span><br><span class="line">i4=i5   <span class="literal">false</span></span><br><span class="line">i4=i5+i6        <span class="literal">true</span></span><br><span class="line">d1=d2   <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>i和i0均是普通类型(int)的变量，所以数据直接存储在栈中，而栈有一个很重要的特性：<strong>栈中的数据可以共享</strong>。当我们定义了int i = 40;，再定义int i0 = 40;这时候会自动检查栈中是否有40这个数据，如果有，i0会直接指向i的40，不会再添加一个新的40。</p><p>1和i2均是引用类型，在栈中存储指针，因为Integer是包装类。由于Integer包装类实现了常量池技术，因此i1、i2的40均是从常量池中获取的，均指向同一个地址，因此i1=12。</p><p>****4.i****4和i5均是引用类型，在栈中存储指针，因为Integer是包装类。但是由于他们各自都是new出来的，因此不再从常量池寻找数据，而是从堆中各自new一个对象，然后各自保存指向对象的指针，所以i4和i5不相等，因为他们所存指针不同，所指向对象不同。</p><p>1和d2均是引用类型，在栈中存储指针，因为Double是包装类。但Double包装类没有实现常量池技术，因此Doubled1=1.0;相当于Double d1=new Double(1.0);，是从堆new一个对象，d2同理。因此d1和d2存放的指针不同，指向的对象不同，所以不相等。</p><p>以上提到的几种基本类型包装类均实现了常量池技术，但他们维护的常量仅仅是【-128至127】这个范围内的常量，如果常量值超过这个范围，就会从堆中创建对象，不再从常量池中取。比如，把上边例子改成Integer i1 = 400; Integer i2 = 400;，很明显超过了127，无法从常量池获取常量，就要从堆中new新的Integer对象，这时i1和i2就不相等了。</p><p>String类型也实现了常量池技术，但是稍微有点不同。String型是先检测常量池中有没有对应字符串，如果有，则取出来；如果没有，则把当前的添加进去。</p><h2 id="创建对象内存分配流程">创建对象内存分配流程</h2><ol><li>方法区：加载类信息。</li><li>堆：初始化对象。（默认初始化，显式初始化，构造器初始化）</li><li>栈：把队中对象的地址赋给栈中变量名。</li></ol>]]></content>
    
    
    <summary type="html">【JavaSE】Java内存分配机制</summary>
    
    
    
    <category term="Java" scheme="http://lmc.pub/categories/Java/"/>
    
    <category term="JavaSE" scheme="http://lmc.pub/categories/Java/JavaSE/"/>
    
    
    <category term="JavaSE" scheme="http://lmc.pub/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>【JavaSE】容易忘记的小点</title>
    <link href="http://lmc.pub/posts/1147267053.html"/>
    <id>http://lmc.pub/posts/1147267053.html</id>
    <published>2023-04-15T22:22:16.000Z</published>
    <updated>2023-04-24T13:10:01.596Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaSE容易疏忽的点">JavaSE容易疏忽的点</h2><ol><li><p>每个Java源文件只能有一个<code>public</code>类，且这个类名要和源文件名保持一致。</p></li><li><p>提示==缺少<code>;</code>的时候==也有可能是少了一个大括号{}</p></li><li><p>byte 和 short 以及char 在进行运算的都是往往会全部先转成 int</p></li><li><p>char 可以保存整数值，但不能保存整数变量，除非强转。</p><p><img src="https://article-picture-resource.oss-cn-chengdu.aliyuncs.com/imags/image-20230403125413934.png" alt="image-20230403125413934"></p></li><li><p>Java里面/只能用作整数上，有小数都会约去。</p></li><li><p>Java中取余%。a%b = a - a/b * b 这才是本质。和5连起来刚刚好。</p></li><li><p>int a = 1 &gt;&gt; 2;   // 1/2/2 = 0</p></li><li><p>int c = 1 &lt;&lt;2;   // 1 * 2 * 2 = 4</p></li><li><p>数组和String一样都是引用类型的，也就是类实例化的对象一样的。</p></li><li><p>二维数组的各个一维之间可以一样长度可以不一样chagn’du</p></li></ol>]]></content>
    
    
    <summary type="html">零碎易错的JavaSE小细节</summary>
    
    
    
    <category term="Java" scheme="http://lmc.pub/categories/Java/"/>
    
    <category term="JavaSE" scheme="http://lmc.pub/categories/Java/JavaSE/"/>
    
    
    <category term="JavaSE" scheme="http://lmc.pub/tags/JavaSE/"/>
    
  </entry>
  
  <entry>
    <title>【Bug】AS在java文件中无法拿到xml中一个id控件</title>
    <link href="http://lmc.pub/posts/2813306735.html"/>
    <id>http://lmc.pub/posts/2813306735.html</id>
    <published>2023-04-14T07:54:14.000Z</published>
    <updated>2023-04-24T13:10:01.577Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v15">描述</h2><p>在做项目的时候，有时候在xml中定义了一个控件加了id。但是去java文件中访问不了。现实爆红，找不到。</p><h2 id="分析-v15">分析</h2><p>AS缓存没缓过来。</p><p>比如你的AS上次没关，然后现在刚打开写。</p><p>就很有可能出现这种情况。</p><h2 id="实现-v14">实现</h2><p>重启一下AS就好了</p><p>或者直接运行一下</p><h2 id="总结-v15">总结</h2>]]></content>
    
    
    <summary type="html">【Bug】AS在java文件中无法拿到xml中一个id控件</summary>
    
    
    
    <category term="Bug" scheme="http://lmc.pub/categories/Bug/"/>
    
    
    <category term="Bug" scheme="http://lmc.pub/tags/Bug/"/>
    
  </entry>
  
  <entry>
    <title>【算法】把二叉搜索树转换为累加树538</title>
    <link href="http://lmc.pub/posts/1639272716.html"/>
    <id>http://lmc.pub/posts/1639272716.html</id>
    <published>2023-04-12T22:31:48.000Z</published>
    <updated>2023-04-24T13:10:01.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v12">描述</h2><h2 id="分析-v12">分析</h2><h2 id="实现-v12">实现</h2><h2 id="总结-v12">总结</h2>]]></content>
    
    
    <summary type="html">【算法】把二叉搜索树转换为累加树538</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】将有序数组转换为二叉搜索树108</title>
    <link href="http://lmc.pub/posts/2698620212.html"/>
    <id>http://lmc.pub/posts/2698620212.html</id>
    <published>2023-04-12T22:31:17.000Z</published>
    <updated>2023-04-24T13:10:01.554Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v11">描述</h2><h2 id="分析-v11">分析</h2><h2 id="实现-v11">实现</h2><h2 id="总结-v11">总结</h2>]]></content>
    
    
    <summary type="html">【算法】将有序数组转换为二叉搜索树108</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】修剪二叉搜索树669</title>
    <link href="http://lmc.pub/posts/819212913.html"/>
    <id>http://lmc.pub/posts/819212913.html</id>
    <published>2023-04-12T22:30:36.000Z</published>
    <updated>2023-04-24T13:10:01.548Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v8">描述</h2><h2 id="分析-v8">分析</h2><h2 id="实现-v8">实现</h2><h2 id="总结-v8">总结</h2>]]></content>
    
    
    <summary type="html">【算法】修剪二叉搜索树669</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】删除二叉搜索树中的节点450</title>
    <link href="http://lmc.pub/posts/306428341.html"/>
    <id>http://lmc.pub/posts/306428341.html</id>
    <published>2023-04-12T22:29:54.000Z</published>
    <updated>2023-04-24T13:10:01.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v7">描述</h2><h2 id="分析-v7">分析</h2><h2 id="实现-v7">实现</h2><h2 id="总结-v7">总结</h2>]]></content>
    
    
    <summary type="html">【算法】删除二叉搜索树中的节点450</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二叉搜索树的插入操作701</title>
    <link href="http://lmc.pub/posts/2259007774.html"/>
    <id>http://lmc.pub/posts/2259007774.html</id>
    <published>2023-04-12T22:29:20.000Z</published>
    <updated>2023-04-24T13:10:01.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v6">描述</h2><h2 id="分析-v6">分析</h2><h2 id="实现-v6">实现</h2><h2 id="总结-v6">总结</h2>]]></content>
    
    
    <summary type="html">【算法】二叉搜索树的插入操作701</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二叉搜索树的最近公共祖先235</title>
    <link href="http://lmc.pub/posts/3463775054.html"/>
    <id>http://lmc.pub/posts/3463775054.html</id>
    <published>2023-04-12T22:28:59.000Z</published>
    <updated>2023-04-24T13:10:01.545Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v2">描述</h2><h2 id="分析-v2">分析</h2><h2 id="实现-v2">实现</h2><h2 id="总结-v2">总结</h2>]]></content>
    
    
    <summary type="html">【算法】二叉搜索树的最近公共祖先235</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二叉树的最近公共祖先236</title>
    <link href="http://lmc.pub/posts/2384664784.html"/>
    <id>http://lmc.pub/posts/2384664784.html</id>
    <published>2023-04-12T22:28:34.000Z</published>
    <updated>2023-04-24T13:10:01.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v5">描述</h2><h2 id="分析-v5">分析</h2><h2 id="实现-v5">实现</h2><h2 id="总结-v5">总结</h2>]]></content>
    
    
    <summary type="html">【算法】二叉树的最近公共祖先236</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二叉搜索树中的众数501</title>
    <link href="http://lmc.pub/posts/2563869577.html"/>
    <id>http://lmc.pub/posts/2563869577.html</id>
    <published>2023-04-12T22:27:56.000Z</published>
    <updated>2023-04-24T13:10:01.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述">描述</h2><h2 id="分析">分析</h2><h2 id="实现">实现</h2><h2 id="总结">总结</h2>]]></content>
    
    
    <summary type="html">【算法】二叉搜索树中的众数501</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二叉搜索树的最小绝对差530</title>
    <link href="http://lmc.pub/posts/2221870846.html"/>
    <id>http://lmc.pub/posts/2221870846.html</id>
    <published>2023-04-12T22:27:22.000Z</published>
    <updated>2023-04-24T13:10:01.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v4">描述</h2><h2 id="分析-v4">分析</h2><h2 id="实现-v4">实现</h2><h2 id="总结-v4">总结</h2>]]></content>
    
    
    <summary type="html">【算法】二叉搜索树的最小绝对差530</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】验证二叉搜索树98</title>
    <link href="http://lmc.pub/posts/2851862665.html"/>
    <id>http://lmc.pub/posts/2851862665.html</id>
    <published>2023-04-12T22:26:43.000Z</published>
    <updated>2023-04-24T13:10:01.575Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v13">描述</h2><h2 id="分析-v13">分析</h2><h2 id="实现-v13">实现</h2><h2 id="总结-v13">总结</h2>]]></content>
    
    
    <summary type="html">【算法】验证二叉搜索树98</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二叉搜索树中的搜索700</title>
    <link href="http://lmc.pub/posts/2744593937.html"/>
    <id>http://lmc.pub/posts/2744593937.html</id>
    <published>2023-04-12T22:26:10.000Z</published>
    <updated>2023-04-24T13:10:01.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v3">描述</h2><h3 id="djoa">djoa</h3><h3 id="djao">djao</h3><h4 id="josa">josa</h4><h2 id="分析-v3">分析</h2><h2 id="实现-v3">实现</h2><h2 id="总结-v3">总结</h2>]]></content>
    
    
    <summary type="html">【算法】二叉搜索树中的搜索700</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】合并二叉树617</title>
    <link href="http://lmc.pub/posts/13151974.html"/>
    <id>http://lmc.pub/posts/13151974.html</id>
    <published>2023-04-12T22:25:30.000Z</published>
    <updated>2023-04-24T13:10:01.551Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v9">描述</h2><h2 id="分析-v9">分析</h2><h2 id="实现-v9">实现</h2><h2 id="总结-v9">总结</h2>]]></content>
    
    
    <summary type="html">【算法】合并二叉树617</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】最大二叉树654</title>
    <link href="http://lmc.pub/posts/1241064268.html"/>
    <id>http://lmc.pub/posts/1241064268.html</id>
    <published>2023-04-12T22:25:12.000Z</published>
    <updated>2023-04-24T13:10:01.608Z</updated>
    
    <content type="html"><![CDATA[<h2 id="描述-v32">描述</h2><h2 id="分析-v29">分析</h2><p>注意类似用数组构造二叉树的题目，每次分隔尽量不要定义新的数组，而是通过下标索引直接在原数组上操作，这样可以节约时间和空间上的开销。</p><h2 id="实现-v30">实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//654最大二叉树</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximumBinaryTree654</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Solution</span>().constructMaximumBinaryTree(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">5</span>&#125;);</span><br><span class="line">MyUtils.printBinaryTree(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">constructMaximumBinaryTree</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> findRootNode(nums, <span class="number">0</span>, nums.length);<span class="comment">//前闭后开</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TreeNode <span class="title function_">findRootNode</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> leftIndex, <span class="type">int</span> rightIndex)</span>&#123;</span><br><span class="line">    <span class="comment">//1. 处理叶子节点和 null 节点</span></span><br><span class="line">    <span class="keyword">if</span> (rightIndex - leftIndex &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//null 节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(rightIndex - leftIndex == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//叶子节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[leftIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 找到 nums 中的最大值以及 maxValueIndex</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxValueIndex</span> <span class="operator">=</span> leftIndex, maxValue = nums[leftIndex];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> leftIndex + <span class="number">1</span>; i &lt; rightIndex; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">    maxValue = nums[i];</span><br><span class="line">    maxValueIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3. 设置 rootNode 以及 left 和 right, 并返回</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(maxValue);</span><br><span class="line">    root.left = findRootNode(nums, leftIndex, maxValueIndex);</span><br><span class="line">    root.right = findRootNode(nums, maxValueIndex + <span class="number">1</span>, rightIndex);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line"><span class="type">int</span> val;</span><br><span class="line">TreeNode left;</span><br><span class="line">TreeNode right;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span>&#123;&#125;;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span>&#123;<span class="built_in">this</span>.val = val;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val, TreeNode left, TreeNode right)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.val = val;</span><br><span class="line"><span class="built_in">this</span>.left = left;</span><br><span class="line"><span class="built_in">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyUtils</span>&#123;</span><br><span class="line"><span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">printBinaryTree</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(); </span><br><span class="line">queue.offer(root);</span><br><span class="line"><span class="type">int</span> size;</span><br><span class="line">TreeNode temp;</span><br><span class="line"><span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">size = queue.size();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">temp = queue.poll();</span><br><span class="line">System.out.print(temp.val + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(temp.left != <span class="literal">null</span>) queue.offer(temp.left);</span><br><span class="line"><span class="keyword">if</span>(temp.right != <span class="literal">null</span>) queue.offer(temp.right);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结-v32">总结</h2>]]></content>
    
    
    <summary type="html">【算法】最大二叉树654</summary>
    
    
    
    <category term="算法" scheme="http://lmc.pub/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="算法" scheme="http://lmc.pub/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
